# Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©: Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª ÙˆØ§Ù„Ø£Ø­Ø¯Ø§Ø«
# Phase 4: Events Management

## Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© | Overview
Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØªØ±ÙƒØ² Ø¹Ù„Ù‰ Ø¨Ù†Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª ÙˆØ§Ù„Ø£Ø­Ø¯Ø§Ø«ØŒ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ØŒ ÙˆØ§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª.

**Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©:** 2-3 Ø£Ø³Ø§Ø¨ÙŠØ¹  
**Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©:** Ù…ØªÙˆØ³Ø·Ø©  
**Ø§Ù„Ø­Ø§Ù„Ø©:** ğŸ”µ ÙÙŠ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± (Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3)

---

## Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© | Main Objectives

### 1. Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
- âœ… Ø¥Ù†Ø´Ø§Ø¡ ÙØ¹Ø§Ù„ÙŠØ§Øª Ø¬Ø¯ÙŠØ¯Ø©
- âœ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„Ù…ÙƒØ§Ù†
- âœ… ØªØ­Ø¯ÙŠØ¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø¶ÙˆØ± Ø§Ù„Ù…Ø³Ù…ÙˆØ­
- âœ… ØªØ³Ø¹ÙŠØ± Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª (Ù…Ø¬Ø§Ù†ÙŠØ©/Ù…Ø¯ÙÙˆØ¹Ø©)
- âœ… Ø­Ø§Ù„Ø§Øª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© (Ù…Ø¬Ø¯ÙˆÙ„Ø©/Ø¬Ø§Ø±ÙŠØ©/Ù…Ù†ØªÙ‡ÙŠØ©/Ù…Ù„ØºØ§Ø©)

### 2. Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙˆØ§Ù„Ø­Ø¶ÙˆØ±
- âœ… Ù†Ø¸Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø­Ø¶ÙˆØ±
- âœ… Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø¶ÙˆØ±
- âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¶ÙˆØ±
- âœ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„

### 3. ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
- âœ… ØµÙØ­Ø© Ø¹Ø±Ø¶ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
- âœ… ØªÙ‚ÙˆÙŠÙ… Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
- âœ… ØµÙØ­Ø© ØªÙØ§ØµÙŠÙ„ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
- âœ… Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨Ø­Ø« ÙˆØ§Ù„ÙÙ„ØªØ±Ø©

### 4. Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
- âœ… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„
- âœ… ØªØ°ÙƒÙŠØ±Ø§Øª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
- âœ… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
- âœ… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ø¥Ù„ØºØ§Ø¡

---

## Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ° | Implementation Steps

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4.1: Backend - Events Module

#### 1. Event DTOs

**apps/api/src/events/dto/create-event.dto.ts:**
```typescript
import { IsString, IsOptional, IsDate, IsNumber, IsInt, IsBoolean, Min, Max, MaxLength, Matches } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';

export class CreateEventDto {
  @ApiProperty({ example: 'Tech Conference 2025' })
  @IsString()
  @MaxLength(200)
  title: string;

  @ApiProperty({ example: 'tech-conference-2025' })
  @IsString()
  @Matches(/^[a-z0-9-]+$/)
  @MaxLength(200)
  slug: string;

  @ApiPropertyOptional({ example: 'Annual technology conference featuring latest trends' })
  @IsString()
  @IsOptional()
  @MaxLength(5000)
  description?: string;

  @ApiProperty({ example: '2025-12-15T09:00:00Z' })
  @IsDate()
  @Type(() => Date)
  startDate: Date;

  @ApiProperty({ example: '2025-12-15T17:00:00Z' })
  @IsDate()
  @Type(() => Date)
  endDate: Date;

  @ApiPropertyOptional({ example: 'Tech Hub Downtown' })
  @IsString()
  @IsOptional()
  @MaxLength(200)
  venue?: string;

  @ApiPropertyOptional({ example: '123 Tech Street, San Francisco, CA' })
  @IsString()
  @IsOptional()
  @MaxLength(500)
  location?: string;

  @ApiPropertyOptional({ example: 100 })
  @IsInt()
  @Min(1)
  @IsOptional()
  @Type(() => Number)
  maxAttendees?: number;

  @ApiPropertyOptional({ example: 49.99 })
  @IsNumber({ maxDecimalPlaces: 2 })
  @Min(0)
  @IsOptional()
  @Type(() => Number)
  price?: number;

  @ApiPropertyOptional({ example: false })
  @IsBoolean()
  @IsOptional()
  isFeatured?: boolean;

  @ApiProperty({ example: 'CONFERENCE', enum: EventType })
  @IsEnum(EventType)
  type: EventType;

  @ApiPropertyOptional({ example: 'uuid-of-category' })
  @IsString()
  @IsOptional()
  categoryId?: string;

  @ApiPropertyOptional({ example: false })
  @IsBoolean()
  @IsOptional()
  isOnline?: boolean;

  @ApiPropertyOptional({ example: 'https://meet.google.com/xxx-yyyy-zzz' })
  @IsString()
  @IsOptional()
  @MaxLength(500)
  meetingUrl?: string;

  @ApiPropertyOptional({ example: 'Laptop required, basic programming knowledge' })
  @IsString()
  @IsOptional()
  @MaxLength(1000)
  requirements?: string;

  @ApiPropertyOptional({ example: ['javascript', 'react', 'programming'] })
  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];

  @ApiPropertyOptional({ example: 'ar' })
  @IsString()
  @IsOptional()
  @MaxLength(5)
  language?: string;
}
```

#### 2. Events Service

**apps/api/src/events/events.service.ts:**
```typescript
import { Injectable, NotFoundException, ConflictException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateEventDto, UpdateEventDto } from './dto';
import { EventStatus } from '@prisma/client';

@Injectable()
export class EventsService {
  constructor(private prisma: PrismaService) {}

  async create(userId: string, createEventDto: CreateEventDto) {
    // Validate dates
    if (createEventDto.endDate <= createEventDto.startDate) {
      throw new BadRequestException('End date must be after start date');
    }

    // Check slug uniqueness
    const existingEvent = await this.prisma.event.findUnique({
      where: { slug: createEventDto.slug },
    });

    if (existingEvent) {
      throw new ConflictException('Event slug already taken');
    }

    return this.prisma.event.create({
      data: {
        ...createEventDto,
        userId,
        status: EventStatus.SCHEDULED,
      },
    });
  }

  async findAll(filters?: {
    status?: EventStatus;
    type?: EventType;
    categoryId?: string;
    upcoming?: boolean;
    featured?: boolean;
    isOnline?: boolean;
    language?: string;
    tags?: string[];
    search?: string;
    page?: number;
    limit?: number;
  }) {
    const { 
      status, 
      type, 
      categoryId, 
      upcoming, 
      featured, 
      isOnline, 
      language, 
      tags, 
      search, 
      page = 1, 
      limit = 20 
    } = filters || {};
    const skip = (page - 1) * limit;

    const where: any = {};

    if (status) {
      where.status = status;
    }

    if (type) {
      where.type = type;
    }

    if (categoryId) {
      where.categoryId = categoryId;
    }

    if (upcoming) {
      where.startDate = { gte: new Date() };
    }

    if (featured !== undefined) {
      where.isFeatured = featured;
    }

    if (isOnline !== undefined) {
      where.isOnline = isOnline;
    }

    if (language) {
      where.language = language;
    }

    if (tags && tags.length > 0) {
      where.tags = {
        hasSome: tags,
      };
    }

    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } },
        { venue: { contains: search, mode: 'insensitive' } },
        { tags: { hasSome: [search] } },
      ];
    }

    const [events, total] = await Promise.all([
      this.prisma.event.findMany({
        where,
        include: {
          user: {
            select: {
              id: true,
              name: true,
            },
          },
          category: {
            select: {
              id: true,
              name: true,
              nameAr: true,
              icon: true,
              color: true,
            },
          },
          _count: {
            select: {
              registrations: true,
            },
          },
        },
        orderBy: { startDate: 'asc' },
        skip,
        take: limit,
      }),
      this.prisma.event.count({ where }),
    ]);

    return {
      events,
      pagination: {
        total,
        page,
        limit,
        pages: Math.ceil(total / limit),
      },
    };
  }

  async findBySlug(slug: string) {
    const event = await this.prisma.event.findUnique({
      where: { slug },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
        _count: {
          select: {
            registrations: true,
          },
        },
      },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    return event;
  }

  async findByUser(userId: string) {
    return this.prisma.event.findMany({
      where: { userId },
      include: {
        _count: {
          select: {
            registrations: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async update(userId: string, eventId: string, updateEventDto: UpdateEventDto) {
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    if (event.userId !== userId) {
      throw new ForbiddenException('Not authorized to update this event');
    }

    // Validate dates if provided
    const startDate = updateEventDto.startDate || event.startDate;
    const endDate = updateEventDto.endDate || event.endDate;

    if (endDate <= startDate) {
      throw new BadRequestException('End date must be after start date');
    }

    return this.prisma.event.update({
      where: { id: eventId },
      data: updateEventDto,
    });
  }

  async updateStatus(userId: string, eventId: string, status: EventStatus) {
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    if (event.userId !== userId) {
      throw new ForbiddenException('Not authorized to update this event');
    }

    return this.prisma.event.update({
      where: { id: eventId },
      data: { status },
    });
  }

  async delete(userId: string, eventId: string) {
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    if (event.userId !== userId) {
      throw new ForbiddenException('Not authorized to delete this event');
    }

    return this.prisma.event.delete({
      where: { id: eventId },
    });
  }

  async getUpcoming(limit = 10) {
    return this.prisma.event.findMany({
      where: {
        startDate: { gte: new Date() },
        status: EventStatus.SCHEDULED,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
        _count: {
          select: {
            registrations: true,
          },
        },
      },
      orderBy: { startDate: 'asc' },
      take: limit,
    });
  }
}
```

#### 3. Event Categories Service

**apps/api/src/events/categories.service.ts:**
```typescript
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

export class CreateCategoryDto {
  @ApiProperty({ example: 'Technology' })
  @IsString()
  @MaxLength(100)
  name: string;

  @ApiProperty({ example: 'Ø§Ù„ØªÙ‚Ù†ÙŠØ©' })
  @IsString()
  @MaxLength(100)
  nameAr: string;

  @ApiPropertyOptional({ example: 'Technology related events' })
  @IsString()
  @IsOptional()
  @MaxLength(500)
  description?: string;

  @ApiPropertyOptional({ example: 'ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„ØªÙ‚Ù†ÙŠØ©' })
  @IsString()
  @IsOptional()
  @MaxLength(500)
  descriptionAr?: string;

  @ApiPropertyOptional({ example: 'fas fa-laptop' })
  @IsString()
  @IsOptional()
  icon?: string;

  @ApiPropertyOptional({ example: '#3B82F6' })
  @IsString()
  @IsOptional()
  @Matches(/^#[0-9A-F]{6}$/i)
  color?: string;
}

@Injectable()
export class EventCategoriesService {
  constructor(private prisma: PrismaService) {}

  async create(createCategoryDto: CreateCategoryDto) {
    // Check if category name already exists
    const existingCategory = await this.prisma.eventCategory.findFirst({
      where: {
        OR: [
          { name: createCategoryDto.name },
          { nameAr: createCategoryDto.nameAr },
        ],
      },
    });

    if (existingCategory) {
      throw new ConflictException('Category name already exists');
    }

    return this.prisma.eventCategory.create({
      data: createCategoryDto,
    });
  }

  async findAll(includeInactive = false) {
    return this.prisma.eventCategory.findMany({
      where: includeInactive ? {} : { isActive: true },
      include: {
        _count: {
          select: {
            events: {
              where: {
                status: 'SCHEDULED',
                startDate: { gte: new Date() },
              },
            },
          },
        },
      },
      orderBy: { name: 'asc' },
    });
  }

  async findById(id: string) {
    const category = await this.prisma.eventCategory.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            events: true,
          },
        },
      },
    });

    if (!category) {
      throw new NotFoundException('Category not found');
    }

    return category;
  }

  async update(id: string, updateCategoryDto: Partial<CreateCategoryDto>) {
    const category = await this.prisma.eventCategory.findUnique({
      where: { id },
    });

    if (!category) {
      throw new NotFoundException('Category not found');
    }

    return this.prisma.eventCategory.update({
      where: { id },
      data: updateCategoryDto,
    });
  }

  async toggleStatus(id: string) {
    const category = await this.prisma.eventCategory.findUnique({
      where: { id },
    });

    if (!category) {
      throw new NotFoundException('Category not found');
    }

    return this.prisma.eventCategory.update({
      where: { id },
      data: { isActive: !category.isActive },
    });
  }

  async delete(id: string) {
    const category = await this.prisma.eventCategory.findUnique({
      where: { id },
      include: {
        _count: {
          select: { events: true },
        },
      },
    });

    if (!category) {
      throw new NotFoundException('Category not found');
    }

    if (category._count.events > 0) {
      throw new ConflictException('Cannot delete category with existing events');
    }

    return this.prisma.eventCategory.delete({
      where: { id },
    });
  }

  async getEventTypeTranslations() {
    return {
      CONFERENCE: { en: 'Conference', ar: 'Ù…Ø¤ØªÙ…Ø±' },
      WORKSHOP: { en: 'Workshop', ar: 'ÙˆØ±Ø´Ø© Ø¹Ù…Ù„' },
      SEMINAR: { en: 'Seminar', ar: 'Ù†Ø¯ÙˆØ©' },
      TRAINING: { en: 'Training', ar: 'Ø¯ÙˆØ±Ø© ØªØ¯Ø±ÙŠØ¨ÙŠØ©' },
      MEETUP: { en: 'Meetup', ar: 'Ù„Ù‚Ø§Ø¡' },
      WEBINAR: { en: 'Webinar', ar: 'Ù†Ø¯ÙˆØ© Ø¹Ø¨Ø± Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª' },
      EXHIBITION: { en: 'Exhibition', ar: 'Ù…Ø¹Ø±Ø¶' },
      NETWORKING: { en: 'Networking', ar: 'ØªÙˆØ§ØµÙ„ Ù…Ù‡Ù†ÙŠ' },
      COMPETITION: { en: 'Competition', ar: 'Ù…Ø³Ø§Ø¨Ù‚Ø©' },
      SOCIAL: { en: 'Social Event', ar: 'ÙØ¹Ø§Ù„ÙŠØ© Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©' },
      CULTURAL: { en: 'Cultural Event', ar: 'ÙØ¹Ø§Ù„ÙŠØ© Ø«Ù‚Ø§ÙÙŠØ©' },
      SPORTS: { en: 'Sports', ar: 'Ø±ÙŠØ§Ø¶ÙŠØ©' },
      EDUCATIONAL: { en: 'Educational', ar: 'ØªØ¹Ù„ÙŠÙ…ÙŠØ©' },
      BUSINESS: { en: 'Business', ar: 'Ø£Ø¹Ù…Ø§Ù„' },
      TECHNOLOGY: { en: 'Technology', ar: 'ØªÙ‚Ù†ÙŠØ©' },
      HEALTH: { en: 'Health', ar: 'ØµØ­ÙŠØ©' },
      ART: { en: 'Art', ar: 'ÙÙ†ÙŠØ©' },
      MUSIC: { en: 'Music', ar: 'Ù…ÙˆØ³ÙŠÙ‚ÙŠØ©' },
      OTHER: { en: 'Other', ar: 'Ø£Ø®Ø±Ù‰' },
    };
  }
}
```

#### 4. Event Reviews Service

**apps/api/src/events/reviews.service.ts:**
```typescript
import { Injectable, NotFoundException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

export class CreateReviewDto {
  @ApiProperty({ example: 5, minimum: 1, maximum: 5 })
  @IsInt()
  @Min(1)
  @Max(5)
  rating: number;

  @ApiPropertyOptional({ example: 'Great event! Learned a lot.' })
  @IsString()
  @IsOptional()
  @MaxLength(2000)
  comment?: string;

  @ApiPropertyOptional({ example: false })
  @IsBoolean()
  @IsOptional()
  isAnonymous?: boolean;
}

@Injectable()
export class EventReviewsService {
  constructor(private prisma: PrismaService) {}

  async createReview(userId: string, eventId: string, createReviewDto: CreateReviewDto) {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© Ø§Ù†ØªÙ‡Øª
    if (event.endDate > new Date()) {
      throw new BadRequestException('Cannot review ongoing events');
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø­Ø¶Ø± Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
    const registration = await this.prisma.eventRegistration.findUnique({
      where: {
        eventId_userId: { eventId, userId },
      },
    });

    if (!registration || registration.status !== 'ATTENDED') {
      throw new ForbiddenException('Only attendees can review events');
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ØªÙ‚ÙŠÙŠÙ… Ø³Ø§Ø¨Ù‚
    const existingReview = await this.prisma.eventReview.findUnique({
      where: {
        eventId_userId: { eventId, userId },
      },
    });

    if (existingReview) {
      throw new BadRequestException('You have already reviewed this event');
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
    const review = await this.prisma.eventReview.create({
      data: {
        eventId,
        userId,
        ...createReviewDto,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    // ØªØ­Ø¯ÙŠØ« Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ù„Ù„ÙØ¹Ø§Ù„ÙŠØ©
    await this.updateEventRatingStats(eventId);

    return review;
  }

  async getEventReviews(eventId: string, page = 1, limit = 20) {
    const skip = (page - 1) * limit;

    const [reviews, total] = await Promise.all([
      this.prisma.eventReview.findMany({
        where: { eventId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.eventReview.count({ where: { eventId } }),
    ]);

    return {
      reviews: reviews.map(review => ({
        ...review,
        user: review.isAnonymous ? { id: 'anonymous', name: 'Ù…Ø¬Ù‡ÙˆÙ„' } : review.user,
      })),
      pagination: {
        total,
        page,
        limit,
        pages: Math.ceil(total / limit),
      },
    };
  }

  async updateEventRatingStats(eventId: string) {
    const stats = await this.prisma.eventReview.aggregate({
      where: { eventId },
      _avg: { rating: true },
      _count: true,
    });

    await this.prisma.event.update({
      where: { id: eventId },
      data: {
        averageRating: stats._avg.rating,
        totalRatings: stats._count,
      },
    });
  }

  async updateReview(userId: string, reviewId: string, updateReviewDto: Partial<CreateReviewDto>) {
    const review = await this.prisma.eventReview.findUnique({
      where: { id: reviewId },
    });

    if (!review) {
      throw new NotFoundException('Review not found');
    }

    if (review.userId !== userId) {
      throw new ForbiddenException('Not authorized to update this review');
    }

    const updatedReview = await this.prisma.eventReview.update({
      where: { id: reviewId },
      data: updateReviewDto,
    });

    // Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
    await this.updateEventRatingStats(review.eventId);

    return updatedReview;
  }

  async deleteReview(userId: string, reviewId: string) {
    const review = await this.prisma.eventReview.findUnique({
      where: { id: reviewId },
    });

    if (!review) {
      throw new NotFoundException('Review not found');
    }

    if (review.userId !== userId) {
      throw new ForbiddenException('Not authorized to delete this review');
    }

    await this.prisma.eventReview.delete({
      where: { id: reviewId },
    });

    // Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
    await this.updateEventRatingStats(review.eventId);
  }
}
```

#### 5. Event Waitlist Service

**apps/api/src/events/waitlist.service.ts:**
```typescript
import { Injectable, NotFoundException, ConflictException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class EventWaitlistService {
  constructor(private prisma: PrismaService) {}

  async joinWaitlist(userId: string, eventId: string) {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
      include: {
        _count: {
          select: {
            registrations: { where: { status: 'REGISTERED' } },
          },
        },
      },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© Ù…Ù…ØªÙ„Ø¦Ø©
    if (!event.maxAttendees || event._count.registrations < event.maxAttendees) {
      throw new BadRequestException('Event is not full, you can register directly');
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³Ø¨Ù‚
    const existingRegistration = await this.prisma.eventRegistration.findUnique({
      where: { eventId_userId: { eventId, userId } },
    });

    if (existingRegistration) {
      throw new ConflictException('Already registered for this event');
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
    const existingWaitlist = await this.prisma.eventWaitlist.findUnique({
      where: { eventId_userId: { eventId, userId } },
    });

    if (existingWaitlist) {
      throw new ConflictException('Already in waitlist for this event');
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
    const lastPosition = await this.prisma.eventWaitlist.findFirst({
      where: { eventId },
      orderBy: { position: 'desc' },
      select: { position: true },
    });

    const position = (lastPosition?.position || 0) + 1;

    return this.prisma.eventWaitlist.create({
      data: {
        eventId,
        userId,
        position,
      },
      include: {
        event: {
          select: { title: true },
        },
      },
    });
  }

  async leaveWaitlist(userId: string, eventId: string) {
    const waitlistEntry = await this.prisma.eventWaitlist.findUnique({
      where: { eventId_userId: { eventId, userId } },
    });

    if (!waitlistEntry) {
      throw new NotFoundException('Not found in waitlist');
    }

    // Ø­Ø°Ù Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
    await this.prisma.eventWaitlist.delete({
      where: { id: waitlistEntry.id },
    });

    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…ÙˆØ§Ø¶Ø¹
    await this.reorderWaitlist(eventId, waitlistEntry.position);
  }

  async processWaitlistWhenSpotAvailable(eventId: string) {
    // Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙˆÙ„ Ø´Ø®Øµ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
    const nextInLine = await this.prisma.eventWaitlist.findFirst({
      where: { eventId, isNotified: false },
      orderBy: { position: 'asc' },
      include: {
        user: true,
        event: true,
      },
    });

    if (!nextInLine) {
      return null;
    }

    // ØªØ³Ø¬ÙŠÙ„Ù‡ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
    const registration = await this.prisma.eventRegistration.create({
      data: {
        eventId,
        userId: nextInLine.userId,
        status: 'REGISTERED',
      },
    });

    // Ø¥Ø²Ø§Ù„ØªÙ‡ Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
    await this.prisma.eventWaitlist.delete({
      where: { id: nextInLine.id },
    });

    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ±ØªÙŠØ¨ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
    await this.reorderWaitlist(eventId, nextInLine.position);

    // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± (ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø®Ø¯Ù…Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù‡Ù†Ø§)
    // await this.notificationService.sendWaitlistNotification(nextInLine);

    return { registration, notifiedUser: nextInLine.user };
  }

  async getEventWaitlist(eventId: string) {
    return this.prisma.eventWaitlist.findMany({
      where: { eventId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
      orderBy: { position: 'asc' },
    });
  }

  async getUserWaitlistPosition(userId: string, eventId: string) {
    const waitlistEntry = await this.prisma.eventWaitlist.findUnique({
      where: { eventId_userId: { eventId, userId } },
    });

    if (!waitlistEntry) {
      return null;
    }

    const countAhead = await this.prisma.eventWaitlist.count({
      where: {
        eventId,
        position: { lt: waitlistEntry.position },
      },
    });

    return {
      position: waitlistEntry.position,
      peopleAhead: countAhead,
      estimatedWaitTime: this.calculateEstimatedWaitTime(countAhead),
    };
  }

  private async reorderWaitlist(eventId: string, deletedPosition: number) {
    // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ§Ø¶Ø¹ ÙƒÙ„ Ù…Ù† Ù‡Ù… Ø¨Ø¹Ø¯ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø­Ø°ÙˆÙ
    await this.prisma.eventWaitlist.updateMany({
      where: {
        eventId,
        position: { gt: deletedPosition },
      },
      data: {
        position: { decrement: 1 },
      },
    });
  }

  private calculateEstimatedWaitTime(peopleAhead: number): string {
    // ØªÙ‚Ø¯ÙŠØ± Ø¨Ø³ÙŠØ·: Ø´Ø®Øµ ÙˆØ§Ø­Ø¯ ÙƒÙ„ ÙŠÙˆÙ…ÙŠÙ† (ÙŠÙ…ÙƒÙ† ØªØ­Ø³ÙŠÙ†Ù‡ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©)
    const estimatedDays = peopleAhead * 2;
    
    if (estimatedDays === 0) return 'Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¬Ø¯Ø§Ù‹';
    if (estimatedDays === 1) return 'Ø®Ù„Ø§Ù„ ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯';
    if (estimatedDays <= 7) return `Ø®Ù„Ø§Ù„ ${estimatedDays} Ø£ÙŠØ§Ù…`;
    if (estimatedDays <= 30) return `Ø®Ù„Ø§Ù„ ${Math.ceil(estimatedDays / 7)} Ø£Ø³Ø§Ø¨ÙŠØ¹`;
    
    return `Ø®Ù„Ø§Ù„ ${Math.ceil(estimatedDays / 30)} Ø£Ø´Ù‡Ø±`;
  }
}
```

#### 6. Calendar Integration Service

**apps/api/src/events/calendar-integration.service.ts:**
```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { google } from 'googleapis';
import { Client } from '@microsoft/microsoft-graph-client';

@Injectable()
export class CalendarIntegrationService {
  constructor(private prisma: PrismaService) {}

  async addToGoogleCalendar(userId: string, eventId: string, accessToken: string) {
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
      include: { user: true },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    try {
      const oauth2Client = new google.auth.OAuth2();
      oauth2Client.setCredentials({ access_token: accessToken });

      const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

      const calendarEvent = {
        summary: event.title,
        description: this.formatEventDescription(event),
        start: {
          dateTime: event.startDate.toISOString(),
          timeZone: event.timezone || 'Asia/Riyadh',
        },
        end: {
          dateTime: event.endDate.toISOString(),
          timeZone: event.timezone || 'Asia/Riyadh',
        },
        location: event.isOnline ? event.meetingUrl : `${event.venue}, ${event.location}`,
        attendees: [{ email: 'user@example.com' }], // ÙŠÙ…ÙƒÙ† ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø¯Ø¹ÙˆÙŠÙ†
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'email', minutes: 24 * 60 }, // ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯ Ù‚Ø¨Ù„
            { method: 'popup', minutes: 10 }, // 10 Ø¯Ù‚Ø§Ø¦Ù‚ Ù‚Ø¨Ù„
          ],
        },
      };

      const response = await calendar.events.insert({
        calendarId: 'primary',
        requestBody: calendarEvent,
      });

      // Ø­ÙØ¸ Ù…Ø¹Ø±Ù Ø§Ù„Ø­Ø¯Ø« ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await this.prisma.calendarIntegration.create({
        data: {
          userId,
          eventId,
          provider: 'GOOGLE',
          externalId: response.data.id!,
          syncStatus: 'SYNCED',
          lastSynced: new Date(),
        },
      });

      return response.data;
    } catch (error) {
      await this.prisma.calendarIntegration.create({
        data: {
          userId,
          eventId,
          provider: 'GOOGLE',
          syncStatus: 'FAILED',
          errorMessage: error.message,
        },
      });
      throw error;
    }
  }

  async addToOutlookCalendar(userId: string, eventId: string, accessToken: string) {
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    try {
      const graphClient = Client.init({
        authProvider: {
          getAccessToken: async () => accessToken,
        },
      });

      const outlookEvent = {
        subject: event.title,
        body: {
          contentType: 'HTML',
          content: this.formatEventDescription(event, 'html'),
        },
        start: {
          dateTime: event.startDate.toISOString(),
          timeZone: event.timezone || 'Asia/Riyadh',
        },
        end: {
          dateTime: event.endDate.toISOString(),
          timeZone: event.timezone || 'Asia/Riyadh',
        },
        location: {
          displayName: event.isOnline ? 'Online Event' : event.venue,
          address: event.isOnline 
            ? { street: event.meetingUrl }
            : { street: event.location },
        },
        isReminderOn: true,
        reminderMinutesBeforeStart: 15,
      };

      const response = await graphClient.api('/me/events').post(outlookEvent);

      await this.prisma.calendarIntegration.create({
        data: {
          userId,
          eventId,
          provider: 'OUTLOOK',
          externalId: response.id,
          syncStatus: 'SYNCED',
          lastSynced: new Date(),
        },
      });

      return response;
    } catch (error) {
      await this.prisma.calendarIntegration.create({
        data: {
          userId,
          eventId,
          provider: 'OUTLOOK',
          syncStatus: 'FAILED',
          errorMessage: error.message,
        },
      });
      throw error;
    }
  }

  async generateICSFile(eventId: string) {
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    const icsContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Rukny.io//Event Management//EN
BEGIN:VEVENT
UID:${event.id}@rukny.io
DTSTAMP:${new Date().toISOString().replace(/[-:]/g, '').split('.')[0]}Z
DTSTART:${event.startDate.toISOString().replace(/[-:]/g, '').split('.')[0]}Z
DTEND:${event.endDate.toISOString().replace(/[-:]/g, '').split('.')[0]}Z
SUMMARY:${event.title}
DESCRIPTION:${this.formatEventDescription(event).replace(/\n/g, '\\n')}
LOCATION:${event.isOnline ? event.meetingUrl : `${event.venue}, ${event.location}`}
STATUS:CONFIRMED
BEGIN:VALARM
TRIGGER:-PT15M
ACTION:DISPLAY
DESCRIPTION:Reminder: ${event.title}
END:VALARM
END:VEVENT
END:VCALENDAR`;

    return icsContent;
  }

  private formatEventDescription(event: any, format: 'text' | 'html' = 'text'): string {
    const isHtml = format === 'html';
    const br = isHtml ? '<br>' : '\n';
    const bold = (text: string) => isHtml ? `<strong>${text}</strong>` : text;

    let description = `${bold('Ø§Ù„ÙˆØµÙ:')} ${event.description || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ'}${br}${br}`;
    
    if (event.requirements) {
      description += `${bold('Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª:')} ${event.requirements}${br}${br}`;
    }
    
    if (event.isOnline && event.meetingUrl) {
      description += `${bold('Ø±Ø§Ø¨Ø· Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹:')} ${event.meetingUrl}${br}`;
      if (event.meetingPassword) {
        description += `${bold('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±:')} ${event.meetingPassword}${br}`;
      }
      description += br;
    }
    
    description += `${bold('Ø§Ù„Ù…Ù†Ø¸Ù…:')} ${event.user?.name || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}${br}`;
    description += `${bold('Ù†ÙˆØ¹ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©:')} ${event.type}${br}`;
    
    if (event.tags && event.tags.length > 0) {
      description += `${bold('Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª:')} ${event.tags.join(', ')}`;
    }

    return description;
  }

  async removeFromCalendar(userId: string, eventId: string, provider: 'GOOGLE' | 'OUTLOOK') {
    const integration = await this.prisma.calendarIntegration.findUnique({
      where: {
        eventId_userId_provider: { eventId, userId, provider },
      },
    });

    if (!integration || !integration.externalId) {
      return;
    }

    try {
      // Ù…Ù†Ø·Ù‚ Ø­Ø°Ù Ø§Ù„Ø­Ø¯Ø« Ù…Ù† Ø§Ù„ØªÙ‚ÙˆÙŠÙ… Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ
      // ÙŠØªØ·Ù„Ø¨ access token ØµØ§Ù„Ø­

      await this.prisma.calendarIntegration.update({
        where: { id: integration.id },
        data: { syncStatus: 'CANCELLED' },
      });
    } catch (error) {
      await this.prisma.calendarIntegration.update({
        where: { id: integration.id },
        data: { 
          syncStatus: 'FAILED',
          errorMessage: error.message,
        },
      });
    }
  }
}
```

#### 7. Event Tickets Service

**apps/api/src/events/tickets.service.ts:**
```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import * as QRCode from 'qrcode';
import { randomBytes } from 'crypto';

@Injectable()
export class EventTicketsService {
  constructor(private prisma: PrismaService) {}

  async generateTicket(registrationId: string) {
    const registration = await this.prisma.eventRegistration.findUnique({
      where: { id: registrationId },
      include: {
        event: true,
        user: true,
      },
    });

    if (!registration) {
      throw new NotFoundException('Registration not found');
    }

    // ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„ØªØ°ÙƒØ±Ø© Ø§Ù„ÙØ±ÙŠØ¯
    const ticketCode = this.generateTicketCode();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØ§Ù†Ø§Øª QR Code
    const qrData = JSON.stringify({
      ticketId: `TKT-${Date.now()}`,
      eventId: registration.eventId,
      userId: registration.userId,
      registrationId: registration.id,
      ticketCode,
      timestamp: Date.now(),
    });

    // ØªÙˆÙ„ÙŠØ¯ ØµÙˆØ±Ø© QR Code
    const qrCodeImage = await QRCode.toDataURL(qrData, {
      errorCorrectionLevel: 'H',
      type: 'image/png',
      quality: 0.92,
      margin: 2,
      color: {
        dark: '#000000',
        light: '#FFFFFF',
      },
      width: 256,
    });

    // Ø­ÙØ¸ Ø§Ù„ØªØ°ÙƒØ±Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const ticket = await this.prisma.eventTicket.create({
      data: {
        registrationId,
        ticketCode,
        qrCode: qrData,
        qrCodeImage,
      },
    });

    return {
      ...ticket,
      registration: {
        event: registration.event,
        user: {
          name: registration.user.name,
          email: registration.user.email,
        },
      },
    };
  }

  async validateTicket(ticketCode: string, eventId: string) {
    const ticket = await this.prisma.eventTicket.findUnique({
      where: { ticketCode },
      include: {
        registration: {
          include: {
            event: true,
            user: true,
          },
        },
      },
    });

    if (!ticket) {
      return { valid: false, message: 'ØªØ°ÙƒØ±Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©' };
    }

    if (ticket.registration.eventId !== eventId) {
      return { valid: false, message: 'Ø§Ù„ØªØ°ÙƒØ±Ø© Ù„Ø§ ØªØ®Øµ Ù‡Ø°Ù‡ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©' };
    }

    if (ticket.isUsed) {
      return { 
        valid: false, 
        message: `ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ°ÙƒØ±Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹ ÙÙŠ ${ticket.usedAt?.toLocaleString('ar-SA')}` 
      };
    }

    const event = ticket.registration.event;
    const now = new Date();

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙˆÙ‚ÙŠØª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
    if (now < new Date(event.startDate.getTime() - 30 * 60 * 1000)) { // 30 Ø¯Ù‚ÙŠÙ‚Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
      return { 
        valid: false, 
        message: 'Ù„Ù… ÙŠØ­Ù† Ù…ÙˆØ¹Ø¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø¹Ø¯' 
      };
    }

    if (now > new Date(event.endDate.getTime() + 60 * 60 * 1000)) { // Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
      return { 
        valid: false, 
        message: 'Ø§Ù†ØªÙ‡Øª ÙØªØ±Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù„ÙØ¹Ø§Ù„ÙŠØ©' 
      };
    }

    return {
      valid: true,
      ticket,
      attendee: {
        name: ticket.registration.user.name,
        email: ticket.registration.user.email,
        registrationDate: ticket.registration.createdAt,
      },
      event: {
        title: event.title,
        startDate: event.startDate,
        venue: event.venue,
      },
    };
  }

  async checkInAttendee(ticketCode: string, eventId: string, checkInMethod = 'QR_SCAN') {
    const validation = await this.validateTicket(ticketCode, eventId);

    if (!validation.valid) {
      return validation;
    }

    const ticket = validation.ticket!;
    const now = new Date();

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ°ÙƒØ±Ø© ÙƒÙ…Ø³ØªØ®Ø¯Ù…Ø©
    await this.prisma.eventTicket.update({
      where: { id: ticket.id },
      data: {
        isUsed: true,
        usedAt: now,
        scanCount: { increment: 1 },
        lastScannedAt: now,
      },
    });

    // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„
    await this.prisma.eventRegistration.update({
      where: { id: ticket.registrationId },
      data: {
        status: 'ATTENDED',
        attendedAt: now,
        checkInMethod,
      },
    });

    return {
      success: true,
      message: 'ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­',
      attendee: validation.attendee,
      checkInTime: now,
    };
  }

  async getEventTickets(eventId: string) {
    return this.prisma.eventTicket.findMany({
      where: {
        registration: { eventId },
      },
      include: {
        registration: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
              },
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async getTicketStats(eventId: string) {
    const stats = await this.prisma.eventTicket.groupBy({
      by: ['isUsed'],
      where: {
        registration: { eventId },
      },
      _count: { id: true },
    });

    const totalTickets = stats.reduce((sum, stat) => sum + stat._count.id, 0);
    const usedTickets = stats.find(stat => stat.isUsed)?._count.id || 0;
    const unusedTickets = totalTickets - usedTickets;

    return {
      totalTickets,
      usedTickets,
      unusedTickets,
      checkInRate: totalTickets > 0 ? (usedTickets / totalTickets) * 100 : 0,
    };
  }

  private generateTicketCode(): string {
    const timestamp = Date.now().toString(36);
    const random = randomBytes(6).toString('hex').toUpperCase();
    return `TKT-${timestamp}-${random}`;
  }

  async resendTicket(registrationId: string) {
    const ticket = await this.prisma.eventTicket.findUnique({
      where: { registrationId },
      include: {
        registration: {
          include: {
            event: true,
            user: true,
          },
        },
      },
    });

    if (!ticket) {
      throw new NotFoundException('Ticket not found');
    }

    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ°ÙƒØ±Ø© Ø¹Ø¨Ø± Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
    // await this.emailService.sendTicket(ticket);

    return { success: true, message: 'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ°ÙƒØ±Ø© Ø¨Ù†Ø¬Ø§Ø­' };
  }
}
```

---

## ğŸ› ï¸ Routes & APIs Documentation | ØªÙˆØ«ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª ÙˆØ§Ù„Ù€ APIs

### **Backend Routes Structure**

#### 1. Events Controller Routes

**apps/api/src/events/events.controller.ts:**
```typescript
import { Controller, Get, Post, Put, Delete, Param, Body, Query, UseGuards } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { EventsService } from './events.service';
import { CreateEventDto, UpdateEventDto } from './dto';

@ApiTags('Events')
@Controller('events')
export class EventsController {
  constructor(private eventsService: EventsService) {}

  // GET /api/events - Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…Ø¹ Ø§Ù„ÙÙ„Ø§ØªØ±
  @Get()
  @ApiOperation({ summary: 'Get all events with filters' })
  async getAllEvents(@Query() filters: any) {
    return this.eventsService.findAll(filters);
  }

  // GET /api/events/upcoming - Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©
  @Get('upcoming')
  @ApiOperation({ summary: 'Get upcoming events' })
  async getUpcomingEvents(@Query('limit') limit?: number) {
    return this.eventsService.getUpcoming(limit);
  }

  // GET /api/events/featured - Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ù…Ù…ÙŠØ²Ø©
  @Get('featured')
  @ApiOperation({ summary: 'Get featured events' })
  async getFeaturedEvents() {
    return this.eventsService.findAll({ featured: true });
  }

  // GET /api/events/categories - ÙØ¦Ø§Øª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
  @Get('categories')
  @ApiOperation({ summary: 'Get event categories' })
  async getCategories() {
    return this.categoriesService.findAll();
  }

  // GET /api/events/types - Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…Ø¹ Ø§Ù„ØªØ±Ø¬Ù…Ø©
  @Get('types')
  @ApiOperation({ summary: 'Get event types with translations' })
  async getEventTypes() {
    return this.categoriesService.getEventTypeTranslations();
  }

  // GET /api/events/:slug - ØªÙØ§ØµÙŠÙ„ ÙØ¹Ø§Ù„ÙŠØ© Ø¨Ø§Ù„Ù€ slug
  @Get(':slug')
  @ApiOperation({ summary: 'Get event details by slug' })
  async getEventBySlug(@Param('slug') slug: string) {
    return this.eventsService.findBySlug(slug);
  }

  // POST /api/events - Ø¥Ù†Ø´Ø§Ø¡ ÙØ¹Ø§Ù„ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
  @Post()
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Create new event' })
  async createEvent(@Body() createEventDto: CreateEventDto, @Request() req) {
    return this.eventsService.create(req.user.id, createEventDto);
  }

  // PUT /api/events/:id - ØªØ­Ø¯ÙŠØ« ÙØ¹Ø§Ù„ÙŠØ©
  @Put(':id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Update event' })
  async updateEvent(
    @Param('id') id: string,
    @Body() updateEventDto: UpdateEventDto,
    @Request() req
  ) {
    return this.eventsService.update(req.user.id, id, updateEventDto);
  }

  // DELETE /api/events/:id - Ø­Ø°Ù ÙØ¹Ø§Ù„ÙŠØ©
  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Delete event' })
  async deleteEvent(@Param('id') id: string, @Request() req) {
    return this.eventsService.delete(req.user.id, id);
  }

  // GET /api/events/user/my-events - ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  @Get('user/my-events')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get user events' })
  async getMyEvents(@Request() req) {
    return this.eventsService.findByUser(req.user.id);
  }
}
```

#### 2. Event Registrations Routes

**apps/api/src/events/registrations.controller.ts:**
```typescript
@ApiTags('Event Registrations')
@Controller('events/:eventId/registrations')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class RegistrationsController {
  constructor(private registrationsService: EventRegistrationsService) {}

  // POST /api/events/:eventId/registrations - Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ ÙØ¹Ø§Ù„ÙŠØ©
  @Post()
  @ApiOperation({ summary: 'Register for event' })
  async registerForEvent(@Param('eventId') eventId: string, @Request() req) {
    return this.registrationsService.register(req.user.id, eventId);
  }

  // DELETE /api/events/:eventId/registrations/:registrationId - Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
  @Delete(':registrationId')
  @ApiOperation({ summary: 'Cancel registration' })
  async cancelRegistration(
    @Param('registrationId') registrationId: string,
    @Request() req
  ) {
    return this.registrationsService.cancel(req.user.id, registrationId);
  }

  // GET /api/events/:eventId/registrations - Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ† (Ù„Ù„Ù…Ù†Ø¸Ù… ÙÙ‚Ø·)
  @Get()
  @ApiOperation({ summary: 'Get event attendees (organizer only)' })
  async getEventAttendees(@Param('eventId') eventId: string) {
    return this.registrationsService.getEventAttendees(eventId);
  }

  // PUT /api/events/:eventId/registrations/:registrationId/attended - ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø­Ø¶ÙˆØ±
  @Put(':registrationId/attended')
  @ApiOperation({ summary: 'Mark as attended' })
  async markAsAttended(
    @Param('registrationId') registrationId: string,
    @Request() req
  ) {
    return this.registrationsService.markAsAttended(req.user.id, registrationId);
  }
}
```

#### 3. Event Reviews Routes

**apps/api/src/events/reviews.controller.ts:**
```typescript
@ApiTags('Event Reviews')
@Controller('events/:eventId/reviews')
export class ReviewsController {
  constructor(private reviewsService: EventReviewsService) {}

  // GET /api/events/:eventId/reviews - Ø¹Ø±Ø¶ ØªÙ‚ÙŠÙŠÙ…Ø§Øª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
  @Get()
  @ApiOperation({ summary: 'Get event reviews' })
  async getEventReviews(
    @Param('eventId') eventId: string,
    @Query('page') page?: number,
    @Query('limit') limit?: number
  ) {
    return this.reviewsService.getEventReviews(eventId, page, limit);
  }

  // POST /api/events/:eventId/reviews - Ø¥Ø¶Ø§ÙØ© ØªÙ‚ÙŠÙŠÙ…
  @Post()
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Add review' })
  async addReview(
    @Param('eventId') eventId: string,
    @Body() createReviewDto: CreateReviewDto,
    @Request() req
  ) {
    return this.reviewsService.createReview(req.user.id, eventId, createReviewDto);
  }

  // PUT /api/events/:eventId/reviews/:reviewId - ØªØ­Ø¯ÙŠØ« ØªÙ‚ÙŠÙŠÙ…
  @Put(':reviewId')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Update review' })
  async updateReview(
    @Param('reviewId') reviewId: string,
    @Body() updateReviewDto: Partial<CreateReviewDto>,
    @Request() req
  ) {
    return this.reviewsService.updateReview(req.user.id, reviewId, updateReviewDto);
  }

  // DELETE /api/events/:eventId/reviews/:reviewId - Ø­Ø°Ù ØªÙ‚ÙŠÙŠÙ…
  @Delete(':reviewId')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Delete review' })
  async deleteReview(@Param('reviewId') reviewId: string, @Request() req) {
    return this.reviewsService.deleteReview(req.user.id, reviewId);
  }
}
```

#### 4. Event Waitlist Routes

**apps/api/src/events/waitlist.controller.ts:**
```typescript
@ApiTags('Event Waitlist')
@Controller('events/:eventId/waitlist')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class WaitlistController {
  constructor(private waitlistService: EventWaitlistService) {}

  // POST /api/events/:eventId/waitlist - Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
  @Post()
  @ApiOperation({ summary: 'Join waitlist' })
  async joinWaitlist(@Param('eventId') eventId: string, @Request() req) {
    return this.waitlistService.joinWaitlist(req.user.id, eventId);
  }

  // DELETE /api/events/:eventId/waitlist - Ù…ØºØ§Ø¯Ø±Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
  @Delete()
  @ApiOperation({ summary: 'Leave waitlist' })
  async leaveWaitlist(@Param('eventId') eventId: string, @Request() req) {
    return this.waitlistService.leaveWaitlist(req.user.id, eventId);
  }

  // GET /api/events/:eventId/waitlist/status - Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
  @Get('status')
  @ApiOperation({ summary: 'Get user waitlist position' })
  async getWaitlistStatus(@Param('eventId') eventId: string, @Request() req) {
    return this.waitlistService.getUserWaitlistPosition(req.user.id, eventId);
  }

  // GET /api/events/:eventId/waitlist - Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†ØªØ¸Ø±ÙŠÙ† (Ù„Ù„Ù…Ù†Ø¸Ù… ÙÙ‚Ø·)
  @Get()
  @ApiOperation({ summary: 'Get event waitlist (organizer only)' })
  async getEventWaitlist(@Param('eventId') eventId: string) {
    return this.waitlistService.getEventWaitlist(eventId);
  }
}
```

#### 5. Event Tickets Routes

**apps/api/src/events/tickets.controller.ts:**
```typescript
@ApiTags('Event Tickets')
@Controller('tickets')
export class TicketsController {
  constructor(private ticketsService: EventTicketsService) {}

  // GET /api/tickets/:registrationId - Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ°ÙƒØ±Ø©
  @Get(':registrationId')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get ticket' })
  async getTicket(@Param('registrationId') registrationId: string) {
    return this.ticketsService.generateTicket(registrationId);
  }

  // POST /api/tickets/:ticketId/resend - Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ°ÙƒØ±Ø©
  @Post(':ticketId/resend')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Resend ticket' })
  async resendTicket(@Param('ticketId') ticketId: string) {
    return this.ticketsService.resendTicket(ticketId);
  }

  // POST /api/events/:eventId/checkin - ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø§Ù„ØªØ°ÙƒØ±Ø©
  @Post('events/:eventId/checkin')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Check in with ticket' })
  async checkIn(
    @Param('eventId') eventId: string,
    @Body() checkInDto: { ticketCode: string; method: string }
  ) {
    return this.ticketsService.checkInAttendee(
      checkInDto.ticketCode,
      eventId,
      checkInDto.method
    );
  }

  // GET /api/events/:eventId/tickets - ØªØ°Ø§ÙƒØ± Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© (Ù„Ù„Ù…Ù†Ø¸Ù… ÙÙ‚Ø·)
  @Get('events/:eventId/tickets')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get event tickets (organizer only)' })
  async getEventTickets(@Param('eventId') eventId: string) {
    return this.ticketsService.getEventTickets(eventId);
  }

  // GET /api/events/:eventId/tickets/stats - Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ°Ø§ÙƒØ±
  @Get('events/:eventId/tickets/stats')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get ticket statistics' })
  async getTicketStats(@Param('eventId') eventId: string) {
    return this.ticketsService.getTicketStats(eventId);
  }
}
```

#### 6. Calendar Integration Routes

**apps/api/src/events/calendar.controller.ts:**
```typescript
@ApiTags('Calendar Integration')
@Controller('events/:eventId/calendar')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class CalendarController {
  constructor(private calendarService: CalendarIntegrationService) {}

  // POST /api/events/:eventId/calendar/google - Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù€ Google Calendar
  @Post('google')
  @ApiOperation({ summary: 'Add to Google Calendar' })
  async addToGoogleCalendar(
    @Param('eventId') eventId: string,
    @Body() body: { accessToken: string },
    @Request() req
  ) {
    return this.calendarService.addToGoogleCalendar(
      req.user.id,
      eventId,
      body.accessToken
    );
  }

  // POST /api/events/:eventId/calendar/outlook - Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù€ Outlook
  @Post('outlook')
  @ApiOperation({ summary: 'Add to Outlook Calendar' })
  async addToOutlookCalendar(
    @Param('eventId') eventId: string,
    @Body() body: { accessToken: string },
    @Request() req
  ) {
    return this.calendarService.addToOutlookCalendar(
      req.user.id,
      eventId,
      body.accessToken
    );
  }

  // GET /api/events/:eventId/calendar/ics - ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù ICS
  @Get('ics')
  @ApiOperation({ summary: 'Download ICS file' })
  async downloadICS(@Param('eventId') eventId: string, @Res() res) {
    const icsContent = await this.calendarService.generateICSFile(eventId);
    res.setHeader('Content-Type', 'text/calendar');
    res.setHeader('Content-Disposition', 'attachment; filename="event.ics"');
    res.send(icsContent);
  }

  // DELETE /api/events/:eventId/calendar/:provider - Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Ø§Ù„ØªÙ‚ÙˆÙŠÙ…
  @Delete(':provider')
  @ApiOperation({ summary: 'Remove from calendar' })
  async removeFromCalendar(
    @Param('eventId') eventId: string,
    @Param('provider') provider: 'GOOGLE' | 'OUTLOOK',
    @Request() req
  ) {
    return this.calendarService.removeFromCalendar(req.user.id, eventId, provider);
  }
}
```

---

### **Frontend API Calls Structure**

#### Frontend API Service

**apps/web/src/lib/api/events.ts:**
```typescript
const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api';

// Events API calls
export const eventsApi = {
  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…Ø¹ Ø§Ù„ÙÙ„Ø§ØªØ±
  getEvents: async (filters?: {
    type?: EventType;
    categoryId?: string;
    upcoming?: boolean;
    featured?: boolean;
    isOnline?: boolean;
    search?: string;
    page?: number;
    limit?: number;
  }) => {
    const params = new URLSearchParams();
    Object.entries(filters || {}).forEach(([key, value]) => {
      if (value !== undefined) params.append(key, value.toString());
    });
    
    const response = await fetch(`${API_BASE}/events?${params}`);
    return response.json();
  },

  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙØ¹Ø§Ù„ÙŠØ© Ø¨Ø§Ù„Ù€ slug
  getEventBySlug: async (slug: string) => {
    const response = await fetch(`${API_BASE}/events/${slug}`);
    return response.json();
  },

  // Ø¥Ù†Ø´Ø§Ø¡ ÙØ¹Ø§Ù„ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
  createEvent: async (eventData: CreateEventDto) => {
    const response = await fetch(`${API_BASE}/events`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getAccessToken()}`,
      },
      body: JSON.stringify(eventData),
    });
    return response.json();
  },

  // Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ ÙØ¹Ø§Ù„ÙŠØ©
  registerForEvent: async (eventId: string) => {
    const response = await fetch(`${API_BASE}/events/${eventId}/registrations`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getAccessToken()}`,
      },
    });
    return response.json();
  },

  // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
  cancelRegistration: async (eventId: string, registrationId: string) => {
    const response = await fetch(`${API_BASE}/events/${eventId}/registrations/${registrationId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${getAccessToken()}`,
      },
    });
    return response.json();
  },

  // Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
  joinWaitlist: async (eventId: string) => {
    const response = await fetch(`${API_BASE}/events/${eventId}/waitlist`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getAccessToken()}`,
      },
    });
    return response.json();
  },

  // Ø¥Ø¶Ø§ÙØ© ØªÙ‚ÙŠÙŠÙ…
  addReview: async (eventId: string, reviewData: CreateReviewDto) => {
    const response = await fetch(`${API_BASE}/events/${eventId}/reviews`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getAccessToken()}`,
      },
      body: JSON.stringify(reviewData),
    });
    return response.json();
  },

  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ°ÙƒØ±Ø©
  getTicket: async (registrationId: string) => {
    const response = await fetch(`${API_BASE}/tickets/${registrationId}`, {
      headers: {
        'Authorization': `Bearer ${getAccessToken()}`,
      },
    });
    return response.json();
  },

  // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø§Ù„ØªØ°ÙƒØ±Ø©
  checkInWithTicket: async (eventId: string, ticketCode: string, method: string) => {
    const response = await fetch(`${API_BASE}/tickets/events/${eventId}/checkin`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getAccessToken()}`,
      },
      body: JSON.stringify({ ticketCode, method }),
    });
    return response.json();
  },

  // Ø¥Ø¶Ø§ÙØ© Ù„Ù„ØªÙ‚ÙˆÙŠÙ…
  addToGoogleCalendar: async (eventId: string, accessToken: string) => {
    const response = await fetch(`${API_BASE}/events/${eventId}/calendar/google`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getAccessToken()}`,
      },
      body: JSON.stringify({ accessToken }),
    });
    return response.json();
  },

  // ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù ICS
  downloadICSFile: async (eventId: string) => {
    const response = await fetch(`${API_BASE}/events/${eventId}/calendar/ics`);
    return response.blob();
  },
};

// Categories API calls
export const categoriesApi = {
  getCategories: async () => {
    const response = await fetch(`${API_BASE}/events/categories`);
    return response.json();
  },

  getEventTypes: async () => {
    const response = await fetch(`${API_BASE}/events/types`);
    return response.json();
  },
};
```

---

### **Frontend Routes Structure**

#### Next.js App Router Structure

```
apps/web/src/app/
â”œâ”€â”€ events/                          # Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
â”‚   â”œâ”€â”€ page.tsx                     # GET /events - ØµÙØ­Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
â”‚   â”œâ”€â”€ [slug]/
â”‚   â”‚   â””â”€â”€ page.tsx                 # GET /events/[slug] - ØªÙØ§ØµÙŠÙ„ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
â”‚   â””â”€â”€ categories/
â”‚       â””â”€â”€ [categoryId]/
â”‚           â””â”€â”€ page.tsx             # GET /events/categories/[categoryId] - ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„ÙØ¦Ø©
â”‚
â”œâ”€â”€ dashboard/                       # Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…
â”‚   â””â”€â”€ events/
â”‚       â”œâ”€â”€ page.tsx                 # GET /dashboard/events - ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
â”‚       â”œâ”€â”€ create/
â”‚       â”‚   â””â”€â”€ page.tsx             # GET /dashboard/events/create - Ø¥Ù†Ø´Ø§Ø¡ ÙØ¹Ø§Ù„ÙŠØ©
â”‚       â”œâ”€â”€ [id]/
â”‚       â”‚   â”œâ”€â”€ page.tsx             # GET /dashboard/events/[id] - ØªØ­Ø±ÙŠØ± Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
â”‚       â”‚   â”œâ”€â”€ edit/
â”‚       â”‚   â”‚   â””â”€â”€ page.tsx         # GET /dashboard/events/[id]/edit - ØªØ­Ø±ÙŠØ±
â”‚       â”‚   â”œâ”€â”€ stats/
â”‚       â”‚   â”‚   â””â”€â”€ page.tsx         # GET /dashboard/events/[id]/stats - Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
â”‚       â”‚   â”œâ”€â”€ attendees/
â”‚       â”‚   â”‚   â””â”€â”€ page.tsx         # GET /dashboard/events/[id]/attendees - Ø§Ù„Ø­Ø¶ÙˆØ±
â”‚       â”‚   â””â”€â”€ reviews/
â”‚       â”‚       â””â”€â”€ page.tsx         # GET /dashboard/events/[id]/reviews - Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª
â”‚       â””â”€â”€ tickets/
â”‚           â””â”€â”€ [ticketId]/
â”‚               â””â”€â”€ page.tsx         # GET /dashboard/events/tickets/[ticketId] - Ø§Ù„ØªØ°ÙƒØ±Ø©
â”‚
â”œâ”€â”€ my/                              # ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø´Ø®ØµÙŠØ©
â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”œâ”€â”€ page.tsx                 # GET /my/events - ÙØ¹Ø§Ù„ÙŠØ§ØªÙŠ Ø§Ù„Ù…Ø³Ø¬Ù„Ø©
â”‚   â”‚   â”œâ”€â”€ waitlist/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx             # GET /my/events/waitlist - Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
â”‚   â”‚   â””â”€â”€ reviews/
â”‚   â”‚       â””â”€â”€ page.tsx             # GET /my/events/reviews - ØªÙ‚ÙŠÙŠÙ…Ø§ØªÙŠ
â”‚   â””â”€â”€ tickets/
â”‚       â”œâ”€â”€ page.tsx                 # GET /my/tickets - ØªØ°Ø§ÙƒØ±ÙŠ
â”‚       â””â”€â”€ [ticketId]/
â”‚           â””â”€â”€ page.tsx             # GET /my/tickets/[ticketId] - ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªØ°ÙƒØ±Ø©
â”‚
â””â”€â”€ api/                             # API Routes (if using Next.js API routes)
    â””â”€â”€ events/
        â”œâ”€â”€ route.ts                 # GET, POST /api/events
        â”œâ”€â”€ [id]/
        â”‚   â””â”€â”€ route.ts             # GET, PUT, DELETE /api/events/[id]
        â””â”€â”€ upload/
            â””â”€â”€ route.ts             # POST /api/events/upload - Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±
```

#### Frontend Route Handlers

**apps/web/src/lib/routes.ts:**
```typescript
// Ù…Ø³Ø§Ø±Ø§Øª Frontend
export const ROUTES = {
  // Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
  EVENTS: '/events',
  EVENT_DETAILS: (slug: string) => `/events/${slug}`,
  EVENT_CATEGORY: (categoryId: string) => `/events/categories/${categoryId}`,
  
  // Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…
  DASHBOARD_EVENTS: '/dashboard/events',
  CREATE_EVENT: '/dashboard/events/create',
  EDIT_EVENT: (id: string) => `/dashboard/events/${id}/edit`,
  EVENT_STATS: (id: string) => `/dashboard/events/${id}/stats`,
  EVENT_ATTENDEES: (id: string) => `/dashboard/events/${id}/attendees`,
  EVENT_REVIEWS: (id: string) => `/dashboard/events/${id}/reviews`,
  
  // Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ©
  MY_EVENTS: '/my/events',
  MY_WAITLIST: '/my/events/waitlist',
  MY_REVIEWS: '/my/events/reviews',
  MY_TICKETS: '/my/tickets',
  TICKET_DETAILS: (ticketId: string) => `/my/tickets/${ticketId}`,
  
  // Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©
  LOGIN: '/login',
  REGISTER: '/register',
  LOGOUT: '/logout',
} as const;

// Ù…Ø³Ø§Ø¹Ø¯ Ù„Ù„ØªÙ†Ù‚Ù„
export const navigate = {
  toEvent: (slug: string) => ROUTES.EVENT_DETAILS(slug),
  toEventStats: (id: string) => ROUTES.EVENT_STATS(id),
  toTicket: (ticketId: string) => ROUTES.TICKET_DETAILS(ticketId),
  // ... Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ÙŠÙ†
};
```

---

### **API Response Formats**

#### Standard Response Format

```typescript
// Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù†Ø§Ø¬Ø­Ø©
{
  success: true,
  data: { /* Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© */ },
  message?: string,
  pagination?: {
    total: number,
    page: number,
    limit: number,
    pages: number
  }
}

// Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø®Ø·Ø£
{
  success: false,
  error: {
    code: string,
    message: string,
    details?: any
  },
  statusCode: number
}
```

#### Events API Responses

```typescript
// GET /api/events
{
  success: true,
  data: {
    events: [
      {
        id: "uuid",
        title: "Ù…Ø¤ØªÙ…Ø± Ø§Ù„ØªÙ‚Ù†ÙŠØ© 2025",
        slug: "tech-conference-2025",
        description: "Ù…Ø¤ØªÙ…Ø± Ø³Ù†ÙˆÙŠ Ù„Ù„ØªÙ‚Ù†ÙŠØ©...",
        startDate: "2025-12-15T09:00:00Z",
        endDate: "2025-12-15T17:00:00Z",
        venue: "Ù…Ø±ÙƒØ² Ø§Ù„Ø±ÙŠØ§Ø¶ Ù„Ù„Ù…Ø¤ØªÙ…Ø±Ø§Øª",
        location: "Ø§Ù„Ø±ÙŠØ§Ø¶ØŒ Ø§Ù„Ù…Ù…Ù„ÙƒØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©",
        maxAttendees: 500,
        price: 150.00,
        type: "CONFERENCE",
        isOnline: false,
        isFeatured: true,
        averageRating: 4.5,
        totalRatings: 23,
        user: {
          id: "uuid",
          name: "Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯"
        },
        category: {
          id: "uuid",
          name: "Technology",
          nameAr: "Ø§Ù„ØªÙ‚Ù†ÙŠØ©",
          icon: "fas fa-laptop-code",
          color: "#3B82F6"
        },
        _count: {
          registrations: 234
        }
      }
    ]
  },
  pagination: {
    total: 150,
    page: 1,
    limit: 20,
    pages: 8
  }
}

// POST /api/events/:eventId/registrations
{
  success: true,
  data: {
    id: "uuid",
    eventId: "uuid",
    userId: "uuid",
    status: "REGISTERED",
    createdAt: "2025-11-01T10:00:00Z",
    event: {
      title: "Ù…Ø¤ØªÙ…Ø± Ø§Ù„ØªÙ‚Ù†ÙŠØ© 2025",
      startDate: "2025-12-15T09:00:00Z",
      venue: "Ù…Ø±ÙƒØ² Ø§Ù„Ø±ÙŠØ§Ø¶ Ù„Ù„Ù…Ø¤ØªÙ…Ø±Ø§Øª"
    }
  },
  message: "ØªÙ… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­"
}

// GET /api/events/:eventId/reviews
{
  success: true,
  data: {
    reviews: [
      {
        id: "uuid",
        rating: 5,
        comment: "ÙØ¹Ø§Ù„ÙŠØ© Ù…Ù…ØªØ§Ø²Ø©ØŒ Ø§Ø³ØªÙØ¯Øª ÙƒØ«ÙŠØ±Ø§Ù‹",
        isAnonymous: false,
        createdAt: "2025-11-01T14:30:00Z",
        user: {
          id: "uuid",
          name: "Ø³Ø§Ø±Ø© Ø£Ø­Ù…Ø¯"
        }
      }
    ]
  },
  pagination: {
    total: 45,
    page: 1,
    limit: 20,
    pages: 3
  }
}
```

---

### **Authentication & Authorization**

#### Protected Routes

```typescript
// Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ù…ØµØ§Ø¯Ù‚Ø©
const PROTECTED_ROUTES = [
  'POST /api/events',
  'PUT /api/events/:id',
  'DELETE /api/events/:id',
  'POST /api/events/:eventId/registrations',
  'POST /api/events/:eventId/reviews',
  'POST /api/events/:eventId/waitlist',
  'GET /api/tickets/:registrationId',
  // ... Ø§Ù„Ù…Ø²ÙŠØ¯
];

// Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© (Ù„Ø§ ØªØ­ØªØ§Ø¬ Ù…ØµØ§Ø¯Ù‚Ø©)
const PUBLIC_ROUTES = [
  'GET /api/events',
  'GET /api/events/:slug',
  'GET /api/events/categories',
  'GET /api/events/types',
  'GET /api/events/:eventId/reviews',
  // ... Ø§Ù„Ù…Ø²ÙŠØ¯
];
```

#### JWT Token Structure

```typescript
// JWT Payload
{
  sub: "user-uuid",
  email: "user@example.com",
  name: "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…",
  role: "USER" | "ADMIN" | "ORGANIZER",
  iat: 1730462400,
  exp: 1730548800
}

// Headers ÙÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
{
  "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "Content-Type": "application/json"
}
```

---

### **Practical Usage Examples | Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…**

#### Frontend Implementation Examples

**1. Ø¹Ø±Ø¶ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…Ø¹ Ø§Ù„ÙÙ„Ø§ØªØ±:**
```typescript
// ÙÙŠ ØµÙØ­Ø© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
const EventsPage = () => {
  const [events, setEvents] = useState([]);
  const [filters, setFilters] = useState({
    type: undefined,
    categoryId: undefined,
    search: '',
    isOnline: undefined,
  });

  useEffect(() => {
    const loadEvents = async () => {
      try {
        const response = await eventsApi.getEvents(filters);
        setEvents(response.data.events);
      } catch (error) {
        console.error('Error loading events:', error);
      }
    };

    loadEvents();
  }, [filters]);

  return (
    <div>
      {/* Ù…ÙƒÙˆÙ† Ø§Ù„ÙÙ„ØªØ±Ø© */}
      <EventTypeFilter 
        onFilterChange={setFilters} 
        currentFilters={filters}
      />
      
      {/* Ø´Ø¨ÙƒØ© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {events.map(event => (
          <EventCard key={event.id} event={event} />
        ))}
      </div>
    </div>
  );
};
```

**2. Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ ÙØ¹Ø§Ù„ÙŠØ©:**
```typescript
// ÙÙŠ ØµÙØ­Ø© ØªÙØ§ØµÙŠÙ„ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
const EventDetailsPage = ({ event }) => {
  const [isRegistering, setIsRegistering] = useState(false);
  const [registrationStatus, setRegistrationStatus] = useState(null);

  const handleRegister = async () => {
    setIsRegistering(true);
    try {
      const response = await eventsApi.registerForEvent(event.id);
      if (response.success) {
        setRegistrationStatus('registered');
        toast.success(response.message);
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ°ÙƒØ±Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
        const ticket = await eventsApi.getTicket(response.data.id);
        // Ø¹Ø±Ø¶ Ø§Ù„ØªØ°ÙƒØ±Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
      }
    } catch (error) {
      if (error.code === 'EVENT_FULL') {
        // Ø¹Ø±Ø¶ Ø®ÙŠØ§Ø± Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        setRegistrationStatus('waitlist_available');
      } else {
        toast.error(error.message);
      }
    } finally {
      setIsRegistering(false);
    }
  };

  const handleJoinWaitlist = async () => {
    try {
      await eventsApi.joinWaitlist(event.id);
      setRegistrationStatus('waitlisted');
      toast.success('ØªÙ… Ø¥Ø¶Ø§ÙØªÙƒ Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±');
    } catch (error) {
      toast.error(error.message);
    }
  };

  return (
    <div>
      {/* Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© */}
      <EventInfo event={event} />
      
      {/* Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ³Ø¬ÙŠÙ„ */}
      {registrationStatus === 'registered' && (
        <Button disabled>âœ“ Ù…Ø³Ø¬Ù„</Button>
      )}
      
      {registrationStatus === 'waitlisted' && (
        <WaitlistStatus eventId={event.id} />
      )}
      
      {!registrationStatus && (
        <Button onClick={handleRegister} disabled={isRegistering}>
          {isRegistering ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„...' : 'Ø³Ø¬Ù„ Ø§Ù„Ø¢Ù†'}
        </Button>
      )}
      
      {registrationStatus === 'waitlist_available' && (
        <div className="space-y-2">
          <p>Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© Ù…Ù…ØªÙ„Ø¦Ø©</p>
          <Button onClick={handleJoinWaitlist}>
            Ø§Ù†Ø¶Ù… Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
          </Button>
        </div>
      )}
    </div>
  );
};
```

**3. Ù…Ø³Ø­ QR Code Ù„Ù„ØªØ°Ø§ÙƒØ±:**
```typescript
// Ù…ÙƒÙˆÙ† Ù…Ø³Ø­ Ø§Ù„ØªØ°Ø§ÙƒØ± Ù„Ù„Ù…Ù†Ø¸Ù…ÙŠÙ†
const QRScannerComponent = ({ eventId, onScanSuccess }) => {
  const [scanning, setScanning] = useState(false);
  
  const handleScan = async (qrData) => {
    try {
      // ÙÙƒ ØªØ´ÙÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª QR Code
      const ticketData = JSON.parse(qrData);
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ°ÙƒØ±Ø© ÙˆØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
      const response = await eventsApi.checkInWithTicket(
        eventId, 
        ticketData.ticketCode, 
        'QR_SCAN'
      );
      
      if (response.success) {
        onScanSuccess({
          attendee: response.attendee,
          checkInTime: response.checkInTime
        });
        
        // Ø¥Ø´Ø¹Ø§Ø± ØµÙˆØªÙŠ Ù„Ù„Ù†Ø¬Ø§Ø­
        playSuccessSound();
      } else {
        // Ø¥Ø´Ø¹Ø§Ø± ØµÙˆØªÙŠ Ù„Ù„ÙØ´Ù„
        playErrorSound();
        alert(response.message);
      }
    } catch (error) {
      console.error('QR Scan error:', error);
      alert('Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø±Ù…Ø²');
    }
  };

  return (
    <div>
      {scanning ? (
        <QRCodeScanner onScan={handleScan} />
      ) : (
        <Button onClick={() => setScanning(true)}>
          Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø³Ø­
        </Button>
      )}
    </div>
  );
};
```

#### Backend Implementation Examples

**4. Middleware Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª:**
```typescript
// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ù„ÙƒÙŠØ© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
@Injectable()
export class EventOwnershipGuard implements CanActivate {
  constructor(private eventsService: EventsService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const userId = request.user.id;
    const eventId = request.params.eventId || request.params.id;

    const event = await this.eventsService.findById(eventId);
    
    if (!event) {
      throw new NotFoundException('Event not found');
    }

    if (event.userId !== userId) {
      throw new ForbiddenException('You are not the owner of this event');
    }

    return true;
  }
}

// Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ Guard
@Controller('events/:eventId/attendees')
@UseGuards(JwtAuthGuard, EventOwnershipGuard)
export class EventAttendeesController {
  // ÙÙ‚Ø· Ù…Ø§Ù„Ùƒ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© ÙŠÙ…ÙƒÙ†Ù‡ Ø±Ø¤ÙŠØ© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø¶ÙˆØ±
}
```

**5. Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±:**
```typescript
// Ù…Ø¹Ø§Ù„Ø¬ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù†Ø¯ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
@Injectable()
export class RegistrationEventHandler {
  constructor(
    private waitlistService: EventWaitlistService,
    private notificationService: NotificationService
  ) {}

  @EventPattern('registration.cancelled')
  async handleRegistrationCancelled(data: { eventId: string, userId: string }) {
    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø¹Ù†Ø¯ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
    const result = await this.waitlistService.processWaitlistWhenSpotAvailable(data.eventId);
    
    if (result && result.notifiedUser) {
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ§Ù„ÙŠ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
      await this.notificationService.sendEmail({
        to: result.notifiedUser.email,
        subject: 'Ù…Ù‚Ø¹Ø¯ Ù…ØªØ§Ø­ ÙÙŠ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©!',
        template: 'waitlist-notification',
        data: {
          userName: result.notifiedUser.name,
          eventTitle: result.registration.event.title,
          eventDate: result.registration.event.startDate,
        }
      });

      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± push
      await this.notificationService.sendPushNotification({
        userId: result.notifiedUser.id,
        title: 'Ù…Ù‚Ø¹Ø¯ Ù…ØªØ§Ø­!',
        body: `ØªÙ… ØªØ³Ø¬ÙŠÙ„Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙÙŠ ${result.registration.event.title}`,
        data: { eventId: data.eventId }
      });
    }
  }
}
```

**6. Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ù…Ù‡Ø§Ù… Ù„Ù„ØªØ°ÙƒÙŠØ±Ø§Øª:**
```typescript
// Ù…Ù‡Ø§Ù… Ù…Ø¬Ø¯ÙˆÙ„Ø© Ù„Ù„ØªØ°ÙƒÙŠØ±Ø§Øª
@Injectable()
export class EventScheduleService {
  constructor(
    private eventsService: EventsService,
    private emailService: EmailService
  ) {}

  // ØªØ°ÙƒÙŠØ± ÙŠÙˆÙ…ÙŠ Ù‚Ø¨Ù„ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
  @Cron('0 9 * * *') // ÙƒÙ„ ÙŠÙˆÙ… Ø§Ù„Ø³Ø§Ø¹Ø© 9 ØµØ¨Ø§Ø­Ø§Ù‹
  async sendDailyReminders() {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);

    const upcomingEvents = await this.eventsService.getEventsStartingOn(tomorrow);

    for (const event of upcomingEvents) {
      const attendees = await this.registrationsService.getEventAttendees(event.id);
      
      for (const attendee of attendees) {
        await this.emailService.sendEventReminder({
          to: attendee.user.email,
          eventTitle: event.title,
          eventDate: event.startDate,
          venue: event.venue,
          isOnline: event.isOnline,
          meetingUrl: event.meetingUrl,
          ticketCode: attendee.ticket?.ticketCode
        });
      }
    }
  }

  // ØªØ°ÙƒÙŠØ± Ù‚Ø¨Ù„ Ø³Ø§Ø¹Ø© Ù…Ù† Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
  @Cron('0 * * * *') // ÙƒÙ„ Ø³Ø§Ø¹Ø©
  async sendHourlyReminders() {
    const oneHourFromNow = new Date();
    oneHourFromNow.setHours(oneHourFromNow.getHours() + 1);

    const startingSoonEvents = await this.eventsService.getEventsStartingAt(oneHourFromNow);

    for (const event of startingSoonEvents) {
      // Ø¥Ø±Ø³Ø§Ù„ ØªØ°ÙƒÙŠØ±Ø§Øª Ù„Ø­Ø¶ÙˆØ± Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
      await this.sendLastMinuteReminders(event);
    }
  }
}
```

---

### **Error Handling & Status Codes**

#### Common Error Responses

```typescript
// 400 Bad Request - Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©
{
  success: false,
  error: {
    code: "VALIDATION_ERROR",
    message: "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©",
    details: {
      "title": ["Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ù…Ø·Ù„ÙˆØ¨"],
      "startDate": ["Ø§Ù„ØªØ§Ø±ÙŠØ® ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† ÙÙŠ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„"]
    }
  },
  statusCode: 400
}

// 401 Unauthorized - ØºÙŠØ± Ù…ØµØ±Ø­
{
  success: false,
  error: {
    code: "UNAUTHORIZED",
    message: "ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹"
  },
  statusCode: 401
}

// 403 Forbidden - Ù…Ù…Ù†ÙˆØ¹
{
  success: false,
  error: {
    code: "FORBIDDEN",
    message: "Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ØªÙ†ÙÙŠØ° Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡"
  },
  statusCode: 403
}

// 404 Not Found - ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯
{
  success: false,
  error: {
    code: "NOT_FOUND",
    message: "Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©"
  },
  statusCode: 404
}

// 409 Conflict - ØªØ¶Ø§Ø±Ø¨
{
  success: false,
  error: {
    code: "ALREADY_REGISTERED",
    message: "Ø£Ù†Øª Ù…Ø³Ø¬Ù„ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©"
  },
  statusCode: 409
}

// 422 Unprocessable Entity - ÙØ¹Ø§Ù„ÙŠØ© Ù…Ù…ØªÙ„Ø¦Ø©
{
  success: false,
  error: {
    code: "EVENT_FULL",
    message: "Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© Ù…Ù…ØªÙ„Ø¦Ø©",
    details: {
      maxAttendees: 100,
      currentAttendees: 100,
      waitlistAvailable: true
    }
  },
  statusCode: 422
}
```

#### Rate Limiting

```typescript
// Ø­Ø¯ÙˆØ¯ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
const RATE_LIMITS = {
  // ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
  'POST /api/events/:eventId/registrations': '5 requests per minute',
  
  // Ø¥Ù†Ø´Ø§Ø¡ ÙØ¹Ø§Ù„ÙŠØ§Øª
  'POST /api/events': '10 requests per hour',
  
  // Ø¥Ø¶Ø§ÙØ© ØªÙ‚ÙŠÙŠÙ…Ø§Øª
  'POST /api/events/:eventId/reviews': '3 requests per hour',
  
  // Ù…Ø³Ø­ Ø§Ù„ØªØ°Ø§ÙƒØ±
  'POST /api/tickets/events/:eventId/checkin': '100 requests per minute',
};
```

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4.2: Backend - Event Registrations

#### 1. ØªØ­Ø¯ÙŠØ« Prisma Schema

Ø¥Ø¶Ø§ÙØ© Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„Ø§Øª:

```prisma
model EventRegistration {
  id              String   @id @default(uuid())
  eventId         String
  userId          String
  status          RegistrationStatus @default(REGISTERED)
  registrationData Json?   // Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© (Ø§Ø³ØªØ¨ÙŠØ§Ù†Ø§ØªØŒ ØªÙØ¶ÙŠÙ„Ø§ØªØŒ Ø¥Ù„Ø®)
  attendedAt      DateTime? // ÙˆÙ‚Øª Ø§Ù„Ø­Ø¶ÙˆØ± Ø§Ù„ÙØ¹Ù„ÙŠ
  checkInMethod   String?  // Ø·Ø±ÙŠÙ‚Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ (QR, manual, etc.)
  notes           String?  // Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø®Ø§ØµØ©
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  event           Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ticket          EventTicket? // Ø§Ù„ØªØ°ÙƒØ±Ø© Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©
  
  @@unique([eventId, userId])
  @@map("event_registrations")
}

enum RegistrationStatus {
  REGISTERED
  ATTENDED
  CANCELLED
}

model EventCategory {
  id          String @id @default(uuid())
  name        String @unique
  nameAr      String @unique // Ø§Ù„Ø§Ø³Ù… Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
  description String?
  descriptionAr String? // Ø§Ù„ÙˆØµÙ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
  icon        String? // Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„ÙØ¦Ø©
  color       String? // Ù„ÙˆÙ† Ø§Ù„ÙØ¦Ø©
  isActive    Boolean @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  events      Event[]
  
  @@map("event_categories")
}

enum EventType {
  CONFERENCE     // Ù…Ø¤ØªÙ…Ø±
  WORKSHOP      // ÙˆØ±Ø´Ø© Ø¹Ù…Ù„
  SEMINAR       // Ù†Ø¯ÙˆØ©
  TRAINING      // Ø¯ÙˆØ±Ø© ØªØ¯Ø±ÙŠØ¨ÙŠØ©
  MEETUP        // Ù„Ù‚Ø§Ø¡
  WEBINAR       // Ù†Ø¯ÙˆØ© Ø¹Ø¨Ø± Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª
  EXHIBITION    // Ù…Ø¹Ø±Ø¶
  NETWORKING    // ØªÙˆØ§ØµÙ„ Ù…Ù‡Ù†ÙŠ
  COMPETITION   // Ù…Ø³Ø§Ø¨Ù‚Ø©
  SOCIAL        // ÙØ¹Ø§Ù„ÙŠØ© Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©
  CULTURAL      // ÙØ¹Ø§Ù„ÙŠØ© Ø«Ù‚Ø§ÙÙŠØ©
  SPORTS        // Ø±ÙŠØ§Ø¶ÙŠØ©
  EDUCATIONAL   // ØªØ¹Ù„ÙŠÙ…ÙŠØ©
  BUSINESS      // Ø£Ø¹Ù…Ø§Ù„
  TECHNOLOGY    // ØªÙ‚Ù†ÙŠØ©
  HEALTH        // ØµØ­ÙŠØ©
  ART           // ÙÙ†ÙŠØ©
  MUSIC         // Ù…ÙˆØ³ÙŠÙ‚ÙŠØ©
  OTHER         // Ø£Ø®Ø±Ù‰
}

// Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª ÙˆØ§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª
model EventReview {
  id        String   @id @default(uuid())
  eventId   String
  userId    String
  rating    Int      @db.SmallInt // 1-5 stars
  comment   String?  @db.Text
  isAnonymous Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId])
  @@map("event_reviews")
}

// Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ù…Ù…ØªÙ„Ø¦Ø©
model EventWaitlist {
  id        String   @id @default(uuid())
  eventId   String
  userId    String
  position  Int      // ØªØ±ØªÙŠØ¨ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
  isNotified Boolean @default(false) // Ù‡Ù„ ØªÙ… Ø¥Ø´Ø¹Ø§Ø±Ù‡ Ø¹Ù†Ø¯ ØªÙˆÙØ± Ù…Ù‚Ø¹Ø¯
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId])
  @@map("event_waitlist")
}

// Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ°Ø§ÙƒØ± ÙˆØ§Ù„Ø¨Ø§Ø±ÙƒÙˆØ¯
model EventTicket {
  id             String   @id @default(uuid())
  registrationId String   @unique
  ticketCode     String   @unique // ÙƒÙˆØ¯ Ø§Ù„ØªØ°ÙƒØ±Ø©
  qrCode         String   @unique // QR code data
  qrCodeImage    String?  // Ø±Ø§Ø¨Ø· ØµÙˆØ±Ø© QR code
  isUsed         Boolean  @default(false)
  usedAt         DateTime?
  scanCount      Int      @default(0) // Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ù…Ø³Ø­
  lastScannedAt  DateTime?
  createdAt      DateTime @default(now())
  
  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  registration   EventRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  
  @@map("event_tickets")
}

// Ø¯Ù…Ø¬ Ø§Ù„ØªÙ‚ÙˆÙŠÙ… Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ
model CalendarIntegration {
  id           String   @id @default(uuid())
  userId       String
  eventId      String
  provider     CalendarProvider
  externalId   String   // Google/Outlook event ID
  syncStatus   SyncStatus @default(PENDING)
  lastSynced   DateTime?
  errorMessage String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  event        Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId, provider])
  @@map("calendar_integrations")
}

enum CalendarProvider {
  GOOGLE
  OUTLOOK
  APPLE
}

enum SyncStatus {
  PENDING
  SYNCED
  FAILED
  CANCELLED
}

// ØªØ­Ø¯ÙŠØ« Event model
model Event {
  id              String      @id @default(uuid())
  title           String
  slug            String      @unique
  description     String?
  startDate       DateTime
  endDate         DateTime
  venue           String?
  location        String?
  maxAttendees    Int?
  price           Float?
  status          EventStatus @default(SCHEDULED)
  isFeatured      Boolean     @default(false)
  type            EventType   @default(OTHER)
  categoryId      String?
  
  // Ù…ÙŠØ²Ø§Øª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
  isOnline        Boolean     @default(false)
  meetingUrl      String?     // Ø±Ø§Ø¨Ø· Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ (Zoom, Google Meet, etc.)
  meetingPassword String?     // ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹
  streamingUrl    String?     // Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
  
  // Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
  requirements    String?     // Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„Ø­Ø¶ÙˆØ±
  agenda          Json?       // Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ (JSON format)
  materials       String[]    // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ÙŠØ©
  tags            String[]    // Ø¹Ù„Ø§Ù…Ø§Øª Ù„Ù„Ø¨Ø­Ø«
  language        String      @default("ar") // Ù„ØºØ© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
  timezone        String      @default("Asia/Riyadh") // Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©
  
  // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
  allowWaitlist   Boolean     @default(true)  // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
  autoApprove     Boolean     @default(true)  // Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
  sendReminders   Boolean     @default(true)  // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ°ÙƒÙŠØ±Ø§Øª
  enableRating    Boolean     @default(true)  // ØªÙ…ÙƒÙŠÙ† Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
  minRatingDays   Int         @default(1)     // Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ Ø£ÙŠØ§Ù… Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© Ù„Ù„ØªÙ‚ÙŠÙŠÙ…
  
  // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
  viewCount       Int         @default(0)     // Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª
  averageRating   Float?      // Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
  totalRatings    Int         @default(0)     // Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
  userId          String
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  category        EventCategory? @relation(fields: [categoryId], references: [id])
  registrations   EventRegistration[]
  reviews         EventReview[]
  waitlist        EventWaitlist[]
  calendarIntegrations CalendarIntegration[]
  
  @@map("events")
}

// ØªØ­Ø¯ÙŠØ« User model
model User {
  // ... Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
  events             Event[]
  eventRegistrations EventRegistration[]
  eventReviews       EventReview[]
  eventWaitlist      EventWaitlist[]
  calendarIntegrations CalendarIntegration[]
}
```

#### 2. Registration Service

**apps/api/src/events/registrations.service.ts:**
```typescript
import { Injectable, NotFoundException, ConflictException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { RegistrationStatus } from '@prisma/client';

@Injectable()
export class EventRegistrationsService {
  constructor(private prisma: PrismaService) {}

  async register(userId: string, eventId: string) {
    // Check if event exists
    const event = await this.prisma.event.findUnique({
      where: { id: eventId },
      include: {
        _count: {
          select: {
            registrations: {
              where: { status: 'REGISTERED' },
            },
          },
        },
      },
    });

    if (!event) {
      throw new NotFoundException('Event not found');
    }

    // Check if event is in the past
    if (event.startDate < new Date()) {
      throw new BadRequestException('Cannot register for past events');
    }

    // Check if event is full
    if (event.maxAttendees && event._count.registrations >= event.maxAttendees) {
      throw new BadRequestException('Event is full');
    }

    // Check if user already registered
    const existingRegistration = await this.prisma.eventRegistration.findUnique({
      where: {
        eventId_userId: {
          eventId,
          userId,
        },
      },
    });

    if (existingRegistration) {
      if (existingRegistration.status === 'CANCELLED') {
        // Reactivate cancelled registration
        return this.prisma.eventRegistration.update({
          where: { id: existingRegistration.id },
          data: { status: 'REGISTERED' },
        });
      }
      throw new ConflictException('Already registered for this event');
    }

    return this.prisma.eventRegistration.create({
      data: {
        eventId,
        userId,
        status: 'REGISTERED',
      },
      include: {
        event: {
          select: {
            id: true,
            title: true,
            startDate: true,
            venue: true,
          },
        },
      },
    });
  }

  async cancel(userId: string, registrationId: string) {
    const registration = await this.prisma.eventRegistration.findUnique({
      where: { id: registrationId },
      include: { event: true },
    });

    if (!registration) {
      throw new NotFoundException('Registration not found');
    }

    if (registration.userId !== userId) {
      throw new ForbiddenException('Not authorized to cancel this registration');
    }

    // Check if event already started
    if (registration.event.startDate < new Date()) {
      throw new BadRequestException('Cannot cancel registration for ongoing or past events');
    }

    return this.prisma.eventRegistration.update({
      where: { id: registrationId },
      data: { status: 'CANCELLED' },
    });
  }

  async getEventAttendees(eventId: string) {
    return this.prisma.eventRegistration.findMany({
      where: {
        eventId,
        status: { in: ['REGISTERED', 'ATTENDED'] },
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
      orderBy: { createdAt: 'asc' },
    });
  }

  async getUserRegistrations(userId: string) {
    return this.prisma.eventRegistration.findMany({
      where: { userId },
      include: {
        event: {
          select: {
            id: true,
            title: true,
            slug: true,
            startDate: true,
            endDate: true,
            venue: true,
            location: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async markAsAttended(eventOwnerId: string, registrationId: string) {
    const registration = await this.prisma.eventRegistration.findUnique({
      where: { id: registrationId },
      include: { event: true },
    });

    if (!registration) {
      throw new NotFoundException('Registration not found');
    }

    if (registration.event.userId !== eventOwnerId) {
      throw new ForbiddenException('Not authorized to update this registration');
    }

    return this.prisma.eventRegistration.update({
      where: { id: registrationId },
      data: { status: 'ATTENDED' },
    });
  }
}
```

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4.3: Frontend - Events Pages

#### 1. ØµÙØ­Ø© Ø¹Ø±Ø¶ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª

**apps/web/src/app/events/page.tsx:**
```typescript
import Link from 'next/link';
import { Calendar, MapPin, Users } from 'lucide-react';
import { getEvents } from '@/lib/api/events';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';

'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { Calendar, Search, Filter } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import EventCard from '@/components/events/EventCard';
import EventTypeFilter from '@/components/events/EventTypeFilter';
import { getEvents, getEventCategories } from '@/lib/api/events';
import { EventType } from '@/types/events';

export default function EventsPage() {
  const [events, setEvents] = useState([]);
  const [categories, setCategories] = useState([]);
  const [loading, setLoading] = useState(true);
  
  // Filters
  const [selectedType, setSelectedType] = useState<EventType | undefined>();
  const [selectedCategory, setSelectedCategory] = useState<string | undefined>();
  const [searchQuery, setSearchQuery] = useState('');
  const [isOnlineFilter, setIsOnlineFilter] = useState<boolean | undefined>();

  useEffect(() => {
    loadData();
  }, []);

  useEffect(() => {
    loadEvents();
  }, [selectedType, selectedCategory, searchQuery, isOnlineFilter]);

  const loadData = async () => {
    try {
      const [eventsData, categoriesData] = await Promise.all([
        getEvents({ upcoming: true }),
        getEventCategories(),
      ]);
      
      setEvents(eventsData.events);
      setCategories(categoriesData);
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadEvents = async () => {
    try {
      const { events } = await getEvents({
        upcoming: true,
        type: selectedType,
        categoryId: selectedCategory,
        search: searchQuery || undefined,
        isOnline: isOnlineFilter,
      });
      setEvents(events);
    } catch (error) {
      console.error('Error loading events:', error);
    }
  };

  const handleSearch = (query: string) => {
    setSearchQuery(query);
  };

  if (loading) {
    return (
      <div className="container max-w-7xl mx-auto px-4 py-10">
        <div className="animate-pulse space-y-4">
          <div className="h-8 bg-gray-200 rounded w-1/4"></div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {[...Array(6)].map((_, i) => (
              <div key={i} className="h-64 bg-gray-200 rounded-lg"></div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="container max-w-7xl mx-auto px-4 py-10" dir="rtl">
      {/* Header */}
      <div className="flex justify-between items-center mb-8">
        <div>
          <h1 className="text-4xl font-bold mb-2">Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©</h1>
          <p className="text-gray-600">Ø§ÙƒØªØ´Ù ÙˆØ§Ù†Ø¶Ù… Ø¥Ù„Ù‰ ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…Ø«ÙŠØ±Ø©</p>
        </div>
        <Button asChild>
          <Link href="/dashboard/events/create">Ø¥Ù†Ø´Ø§Ø¡ ÙØ¹Ø§Ù„ÙŠØ©</Link>
        </Button>
      </div>

      {/* Search and Filters */}
      <div className="mb-8 space-y-4">
        {/* Search Bar */}
        <div className="relative">
          <Search className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
          <Input
            placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª..."
            value={searchQuery}
            onChange={(e) => handleSearch(e.target.value)}
            className="pr-10"
          />
        </div>

        {/* Type and Category Filters */}
        <EventTypeFilter
          selectedType={selectedType}
          selectedCategory={selectedCategory}
          categories={categories}
          onTypeChange={setSelectedType}
          onCategoryChange={setSelectedCategory}
        />

        {/* Additional Filters */}
        <div className="flex flex-wrap gap-2">
          <Button
            variant={isOnlineFilter === true ? 'default' : 'outline'}
            size="sm"
            onClick={() => setIsOnlineFilter(isOnlineFilter === true ? undefined : true)}
          >
            ÙØ¹Ø§Ù„ÙŠØ§Øª Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†
          </Button>
          <Button
            variant={isOnlineFilter === false ? 'default' : 'outline'}
            size="sm"
            onClick={() => setIsOnlineFilter(isOnlineFilter === false ? undefined : false)}
          >
            ÙØ¹Ø§Ù„ÙŠØ§Øª Ø­Ø¶ÙˆØ±ÙŠØ©
          </Button>
        </div>
      </div>

      {/* Events Grid */}
      {events.length === 0 ? (
        <div className="text-center py-20 text-gray-500">
          <Calendar className="w-16 h-16 mx-auto mb-4 opacity-50" />
          <p className="text-lg mb-2">Ù„Ø§ ØªÙˆØ¬Ø¯ ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…ØªØ§Ø­Ø©</p>
          <p className="text-sm">Ø¬Ø±Ø¨ ØªØºÙŠÙŠØ± ÙÙ„Ø§ØªØ± Ø§Ù„Ø¨Ø­Ø« Ø£Ùˆ ØªØµÙØ­ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {events.map((event) => (
            <EventCard key={event.id} event={event} />
          ))}
        </div>
      )}

      {/* Categories Section */}
      {categories.length > 0 && (
        <div className="mt-16">
          <h2 className="text-2xl font-bold mb-6">ØªØµÙØ­ Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø©</h2>
          <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
            {categories.map((category) => (
              <Button
                key={category.id}
                variant="outline"
                className="h-20 flex flex-col items-center gap-2 hover:shadow-md transition-shadow"
                onClick={() => setSelectedCategory(category.id)}
                style={{
                  backgroundColor: selectedCategory === category.id 
                    ? `${category.color}20` 
                    : 'transparent',
                  borderColor: selectedCategory === category.id 
                    ? category.color 
                    : undefined,
                }}
              >
                {category.icon && (
                  <i 
                    className={category.icon} 
                    style={{ color: category.color, fontSize: '1.5rem' }}
                  />
                )}
                <span className="text-xs font-medium text-center">
                  {category.nameAr || category.name}
                </span>
                <span className="text-xs text-gray-500">
                  ({category._count.events})
                </span>
              </Button>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

#### 2. Ù…ÙƒÙˆÙ† ØªØµÙ†ÙŠÙ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª

**apps/web/src/components/events/EventTypeFilter.tsx:**
```tsx
'use client';

import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { EventType } from '@/types/events';

interface EventTypeFilterProps {
  selectedType?: EventType;
  selectedCategory?: string;
  categories: any[];
  onTypeChange: (type: EventType | undefined) => void;
  onCategoryChange: (categoryId: string | undefined) => void;
}

const eventTypeTranslations = {
  CONFERENCE: 'Ù…Ø¤ØªÙ…Ø±',
  WORKSHOP: 'ÙˆØ±Ø´Ø© Ø¹Ù…Ù„',
  SEMINAR: 'Ù†Ø¯ÙˆØ©',
  TRAINING: 'Ø¯ÙˆØ±Ø© ØªØ¯Ø±ÙŠØ¨ÙŠØ©',
  MEETUP: 'Ù„Ù‚Ø§Ø¡',
  WEBINAR: 'Ù†Ø¯ÙˆØ© Ø¹Ø¨Ø± Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª',
  EXHIBITION: 'Ù…Ø¹Ø±Ø¶',
  NETWORKING: 'ØªÙˆØ§ØµÙ„ Ù…Ù‡Ù†ÙŠ',
  COMPETITION: 'Ù…Ø³Ø§Ø¨Ù‚Ø©',
  SOCIAL: 'ÙØ¹Ø§Ù„ÙŠØ© Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©',
  CULTURAL: 'ÙØ¹Ø§Ù„ÙŠØ© Ø«Ù‚Ø§ÙÙŠØ©',
  SPORTS: 'Ø±ÙŠØ§Ø¶ÙŠØ©',
  EDUCATIONAL: 'ØªØ¹Ù„ÙŠÙ…ÙŠØ©',
  BUSINESS: 'Ø£Ø¹Ù…Ø§Ù„',
  TECHNOLOGY: 'ØªÙ‚Ù†ÙŠØ©',
  HEALTH: 'ØµØ­ÙŠØ©',
  ART: 'ÙÙ†ÙŠØ©',
  MUSIC: 'Ù…ÙˆØ³ÙŠÙ‚ÙŠØ©',
  OTHER: 'Ø£Ø®Ø±Ù‰',
};

export default function EventTypeFilter({
  selectedType,
  selectedCategory,
  categories,
  onTypeChange,
  onCategoryChange,
}: EventTypeFilterProps) {
  return (
    <div className="flex flex-col sm:flex-row gap-4 mb-6">
      {/* ØªØµÙ†ÙŠÙ Ù†ÙˆØ¹ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© */}
      <div className="flex-1">
        <label className="block text-sm font-medium mb-2">Ù†ÙˆØ¹ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©</label>
        <Select
          value={selectedType || ''}
          onValueChange={(value) => onTypeChange(value as EventType || undefined)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹</SelectItem>
            {Object.entries(eventTypeTranslations).map(([key, label]) => (
              <SelectItem key={key} value={key}>
                {label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* ØªØµÙ†ÙŠÙ Ø§Ù„ÙØ¦Ø© */}
      <div className="flex-1">
        <label className="block text-sm font-medium mb-2">ÙØ¦Ø© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©</label>
        <Select
          value={selectedCategory || ''}
          onValueChange={(value) => onCategoryChange(value || undefined)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„ÙØ¦Ø©" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ¦Ø§Øª</SelectItem>
            {categories.map((category) => (
              <SelectItem key={category.id} value={category.id}>
                <div className="flex items-center gap-2">
                  {category.icon && (
                    <i 
                      className={category.icon} 
                      style={{ color: category.color }}
                    />
                  )}
                  {category.nameAr || category.name}
                </div>
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙÙ„Ø§ØªØ± */}
      {(selectedType || selectedCategory) && (
        <div className="flex items-end">
          <Button
            variant="outline"
            onClick={() => {
              onTypeChange(undefined);
              onCategoryChange(undefined);
            }}
          >
            Ù…Ø³Ø­ Ø§Ù„ÙÙ„Ø§ØªØ±
          </Button>
        </div>
      )}
    </div>
  );
}
```

#### 3. Ù…ÙƒÙˆÙ† Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© Ø§Ù„Ù…Ø­Ø¯Ø«Ø©

**apps/web/src/components/events/EventCard.tsx:**
```tsx
import Link from 'next/link';
import { Calendar, MapPin, Users, Globe, Video } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

interface EventCardProps {
  event: {
    id: string;
    title: string;
    slug: string;
    type: string;
    startDate: string;
    venue?: string;
    isOnline: boolean;
    isFeatured: boolean;
    price?: number;
    language: string;
    tags: string[];
    user: {
      name: string;
    };
    category?: {
      nameAr: string;
      icon?: string;
      color?: string;
    };
    _count: {
      registrations: number;
    };
    maxAttendees?: number;
  };
}

const eventTypeTranslations = {
  CONFERENCE: 'Ù…Ø¤ØªÙ…Ø±',
  WORKSHOP: 'ÙˆØ±Ø´Ø© Ø¹Ù…Ù„',
  SEMINAR: 'Ù†Ø¯ÙˆØ©',
  TRAINING: 'Ø¯ÙˆØ±Ø© ØªØ¯Ø±ÙŠØ¨ÙŠØ©',
  MEETUP: 'Ù„Ù‚Ø§Ø¡',
  WEBINAR: 'Ù†Ø¯ÙˆØ© Ø¹Ø¨Ø± Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª',
  EXHIBITION: 'Ù…Ø¹Ø±Ø¶',
  NETWORKING: 'ØªÙˆØ§ØµÙ„ Ù…Ù‡Ù†ÙŠ',
  COMPETITION: 'Ù…Ø³Ø§Ø¨Ù‚Ø©',
  SOCIAL: 'ÙØ¹Ø§Ù„ÙŠØ© Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©',
  CULTURAL: 'ÙØ¹Ø§Ù„ÙŠØ© Ø«Ù‚Ø§ÙÙŠØ©',
  SPORTS: 'Ø±ÙŠØ§Ø¶ÙŠØ©',
  EDUCATIONAL: 'ØªØ¹Ù„ÙŠÙ…ÙŠØ©',
  BUSINESS: 'Ø£Ø¹Ù…Ø§Ù„',
  TECHNOLOGY: 'ØªÙ‚Ù†ÙŠØ©',
  HEALTH: 'ØµØ­ÙŠØ©',
  ART: 'ÙÙ†ÙŠØ©',
  MUSIC: 'Ù…ÙˆØ³ÙŠÙ‚ÙŠØ©',
  OTHER: 'Ø£Ø®Ø±Ù‰',
};

export default function EventCard({ event }: EventCardProps) {
  return (
    <Link href={`/events/${event.slug}`}>
      <Card className="hover:shadow-lg transition-shadow cursor-pointer h-full">
        <CardHeader>
          <div className="flex justify-between items-start mb-2">
            <CardTitle className="text-xl line-clamp-2">
              {event.title}
            </CardTitle>
            <div className="flex flex-col gap-2">
              {event.isFeatured && (
                <Badge variant="secondary">Ù…Ù…ÙŠØ²</Badge>
              )}
              {event.isOnline && (
                <Badge variant="outline" className="text-blue-600">
                  <Video className="w-3 h-3 mr-1" />
                  Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†
                </Badge>
              )}
            </div>
          </div>
          
          <div className="flex items-center justify-between">
            <p className="text-sm text-gray-500">Ø¨ÙˆØ§Ø³Ø·Ø© {event.user.name}</p>
            {event.language !== 'ar' && (
              <Badge variant="outline" className="text-xs">
                <Globe className="w-3 h-3 mr-1" />
                {event.language === 'en' ? 'English' : event.language}
              </Badge>
            )}
          </div>
        </CardHeader>

        <CardContent className="space-y-3">
          {/* Ù†ÙˆØ¹ ÙˆÙØ¦Ø© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© */}
          <div className="flex flex-wrap gap-2">
            <Badge 
              variant="outline" 
              className="text-xs"
              style={{ 
                backgroundColor: event.category?.color ? `${event.category.color}20` : undefined,
                borderColor: event.category?.color 
              }}
            >
              {event.category?.icon && (
                <i className={`${event.category.icon} mr-1`} />
              )}
              {eventTypeTranslations[event.type as keyof typeof eventTypeTranslations] || event.type}
            </Badge>
            
            {event.category && (
              <Badge variant="outline" className="text-xs">
                {event.category.nameAr}
              </Badge>
            )}
          </div>

          {/* ØªØ§Ø±ÙŠØ® Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© */}
          <div className="flex items-center text-sm text-gray-600">
            <Calendar className="w-4 h-4 mr-2" />
            {new Date(event.startDate).toLocaleDateString('ar-SA', {
              month: 'long',
              day: 'numeric',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
            })}
          </div>

          {/* Ù…ÙƒØ§Ù† Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© */}
          {event.venue && !event.isOnline && (
            <div className="flex items-center text-sm text-gray-600">
              <MapPin className="w-4 h-4 mr-2" />
              {event.venue}
            </div>
          )}

          {/* Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª */}
          {event.tags && event.tags.length > 0 && (
            <div className="flex flex-wrap gap-1">
              {event.tags.slice(0, 3).map((tag, index) => (
                <span 
                  key={index}
                  className="px-2 py-1 bg-gray-100 text-gray-600 text-xs rounded-md"
                >
                  #{tag}
                </span>
              ))}
              {event.tags.length > 3 && (
                <span className="text-xs text-gray-500">
                  +{event.tags.length - 3} Ø§Ù„Ù…Ø²ÙŠØ¯
                </span>
              )}
            </div>
          )}

          {/* Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø¶ÙˆØ± ÙˆØ§Ù„Ø³Ø¹Ø± */}
          <div className="flex items-center justify-between pt-2">
            <div className="flex items-center text-sm text-gray-600">
              <Users className="w-4 h-4 mr-2" />
              {event._count.registrations}
              {event.maxAttendees && ` / ${event.maxAttendees}`} Ù…Ø´Ø§Ø±Ùƒ
            </div>

            {event.price !== undefined && event.price !== null ? (
              <Badge variant="outline">
                {event.price === 0 ? 'Ù…Ø¬Ø§Ù†ÙŠ' : `${event.price.toFixed(2)} Ø±ÙŠØ§Ù„`}
              </Badge>
            ) : (
              <Badge variant="outline">Ù…Ø¬Ø§Ù†ÙŠ</Badge>
            )}
          </div>
        </CardContent>
      </Card>
    </Link>
  );
}
```

#### 4. ØµÙØ­Ø© ØªÙØ§ØµÙŠÙ„ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
```typescript
'use client';

import { useState } from 'react';
import { useSession } from 'next-auth/react';
import Image from 'next/image';
import { Calendar, MapPin, Users, Clock, DollarSign } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { registerForEvent } from '@/lib/api/events';

export default function EventDetailPage({ event }: { event: any }) {
  const { data: session } = useSession();
  const [isRegistering, setIsRegistering] = useState(false);
  const [isRegistered, setIsRegistered] = useState(false);

  const handleRegister = async () => {
    if (!session) {
      window.location.href = '/login';
      return;
    }

    setIsRegistering(true);
    try {
      await registerForEvent(event.id);
      setIsRegistered(true);
      alert('Successfully registered!');
    } catch (error: any) {
      alert(error.message || 'Failed to register');
    } finally {
      setIsRegistering(false);
    }
  };

  const isFull = event.maxAttendees && event._count.registrations >= event.maxAttendees;
  const isPast = new Date(event.startDate) < new Date();

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container max-w-5xl mx-auto px-4 py-10">
        <Card>
          <CardHeader>
            <div className="flex justify-between items-start">
              <div className="flex-1">
                <CardTitle className="text-3xl mb-2">{event.title}</CardTitle>
                <p className="text-gray-600">Organized by {event.user.name}</p>
              </div>
              {event.isFeatured && (
                <Badge variant="secondary" className="ml-4">Featured</Badge>
              )}
            </div>
          </CardHeader>

          <CardContent className="space-y-6">
            {/* Event Details */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="flex items-start space-x-3">
                <Calendar className="w-5 h-5 text-gray-500 mt-1" />
                <div>
                  <p className="font-semibold">Start Date</p>
                  <p className="text-gray-600">
                    {new Date(event.startDate).toLocaleString()}
                  </p>
                </div>
              </div>

              <div className="flex items-start space-x-3">
                <Clock className="w-5 h-5 text-gray-500 mt-1" />
                <div>
                  <p className="font-semibold">End Date</p>
                  <p className="text-gray-600">
                    {new Date(event.endDate).toLocaleString()}
                  </p>
                </div>
              </div>

              {event.venue && (
                <div className="flex items-start space-x-3">
                  <MapPin className="w-5 h-5 text-gray-500 mt-1" />
                  <div>
                    <p className="font-semibold">Venue</p>
                    <p className="text-gray-600">{event.venue}</p>
                    {event.location && (
                      <p className="text-sm text-gray-500">{event.location}</p>
                    )}
                  </div>
                </div>
              )}

              <div className="flex items-start space-x-3">
                <Users className="w-5 h-5 text-gray-500 mt-1" />
                <div>
                  <p className="font-semibold">Attendees</p>
                  <p className="text-gray-600">
                    {event._count.registrations}
                    {event.maxAttendees && ` / ${event.maxAttendees}`}
                  </p>
                </div>
              </div>

              {event.price !== null && (
                <div className="flex items-start space-x-3">
                  <DollarSign className="w-5 h-5 text-gray-500 mt-1" />
                  <div>
                    <p className="font-semibold">Price</p>
                    <p className="text-gray-600">
                      {event.price === 0 ? 'Free' : `$${event.price.toFixed(2)}`}
                    </p>
                  </div>
                </div>
              )}
            </div>

            {/* Description */}
            {event.description && (
              <div>
                <h3 className="font-semibold text-lg mb-2">About This Event</h3>
                <p className="text-gray-700 whitespace-pre-wrap">{event.description}</p>
              </div>
            )}

            {/* Registration Button */}
            <div className="pt-4">
              {isRegistered ? (
                <Button disabled className="w-full">
                  âœ“ Registered
                </Button>
              ) : (
                <Button
                  onClick={handleRegister}
                  disabled={isRegistering || isFull || isPast}
                  className="w-full"
                >
                  {isRegistering
                    ? 'Registering...'
                    : isFull
                    ? 'Event Full'
                    : isPast
                    ? 'Event Ended'
                    : 'Register Now'}
                </Button>
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4.4: Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ© ÙˆØ¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…

#### 1. Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙˆÙ„ÙŠØ© Ù„ÙØ¦Ø§Øª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª

**apps/api/prisma/seeds/event-categories.ts:**
```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export const eventCategoriesData = [
  {
    name: 'Technology',
    nameAr: 'Ø§Ù„ØªÙ‚Ù†ÙŠØ© ÙˆØ§Ù„Ø¨Ø±Ù…Ø¬Ø©',
    description: 'Technology and programming related events',
    descriptionAr: 'ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„ØªÙ‚Ù†ÙŠØ© ÙˆØ§Ù„Ø¨Ø±Ù…Ø¬Ø©',
    icon: 'fas fa-laptop-code',
    color: '#3B82F6',
  },
  {
    name: 'Business',
    nameAr: 'Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ ÙˆØ±ÙŠØ§Ø¯Ø© Ø§Ù„Ø£Ø¹Ù…Ø§Ù„',
    description: 'Business and entrepreneurship events',
    descriptionAr: 'ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ ÙˆØ±ÙŠØ§Ø¯Ø© Ø§Ù„Ø£Ø¹Ù…Ø§Ù„',
    icon: 'fas fa-briefcase',
    color: '#059669',
  },
  {
    name: 'Health',
    nameAr: 'Ø§Ù„ØµØ­Ø© ÙˆØ§Ù„Ù„ÙŠØ§Ù‚Ø©',
    description: 'Health and fitness related events',
    descriptionAr: 'ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„ØµØ­Ø© ÙˆØ§Ù„Ù„ÙŠØ§Ù‚Ø© Ø§Ù„Ø¨Ø¯Ù†ÙŠØ©',
    icon: 'fas fa-heartbeat',
    color: '#DC2626',
  },
  {
    name: 'Education',
    nameAr: 'Ø§Ù„ØªØ¹Ù„ÙŠÙ… ÙˆØ§Ù„ØªØ·ÙˆÙŠØ±',
    description: 'Educational and development events',
    descriptionAr: 'ÙØ¹Ø§Ù„ÙŠØ§Øª ØªØ¹Ù„ÙŠÙ…ÙŠØ© ÙˆØªØ·ÙˆÙŠØ±ÙŠØ©',
    icon: 'fas fa-graduation-cap',
    color: '#7C3AED',
  },
  {
    name: 'Art & Culture',
    nameAr: 'Ø§Ù„ÙÙ† ÙˆØ§Ù„Ø«Ù‚Ø§ÙØ©',
    description: 'Arts, culture and creative events',
    descriptionAr: 'ÙØ¹Ø§Ù„ÙŠØ§Øª ÙÙ†ÙŠØ© ÙˆØ«Ù‚Ø§ÙÙŠØ© ÙˆØ¥Ø¨Ø¯Ø§Ø¹ÙŠØ©',
    icon: 'fas fa-palette',
    color: '#DB2777',
  },
  {
    name: 'Sports',
    nameAr: 'Ø§Ù„Ø±ÙŠØ§Ø¶Ø© ÙˆØ§Ù„Ø£Ù†Ø´Ø·Ø© Ø§Ù„Ø¨Ø¯Ù†ÙŠØ©',
    description: 'Sports and physical activities',
    descriptionAr: 'Ø§Ù„Ø±ÙŠØ§Ø¶Ø© ÙˆØ§Ù„Ø£Ù†Ø´Ø·Ø© Ø§Ù„Ø¨Ø¯Ù†ÙŠØ©',
    icon: 'fas fa-running',
    color: '#EA580C',
  },
  {
    name: 'Social',
    nameAr: 'Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©',
    description: 'Social gatherings and networking',
    descriptionAr: 'Ø§Ù„ØªØ¬Ù…Ø¹Ø§Øª Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ© ÙˆØ§Ù„ØªÙˆØ§ØµÙ„',
    icon: 'fas fa-users',
    color: '#0891B2',
  },
  {
    name: 'Food & Drink',
    nameAr: 'Ø§Ù„Ø·Ø¹Ø§Ù… ÙˆØ§Ù„Ø´Ø±Ø§Ø¨',
    description: 'Culinary events and food experiences',
    descriptionAr: 'ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ø·Ø¨Ø® ÙˆØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ø·Ø¹Ø§Ù…',
    icon: 'fas fa-utensils',
    color: '#65A30D',
  },
  {
    name: 'Music',
    nameAr: 'Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ ÙˆØ§Ù„ØªØ±ÙÙŠÙ‡',
    description: 'Music and entertainment events',
    descriptionAr: 'ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…ÙˆØ³ÙŠÙ‚ÙŠØ© ÙˆØªØ±ÙÙŠÙ‡ÙŠØ©',
    icon: 'fas fa-music',
    color: '#C026D3',
  },
  {
    name: 'Travel',
    nameAr: 'Ø§Ù„Ø³ÙØ± ÙˆØ§Ù„Ø³ÙŠØ§Ø­Ø©',
    description: 'Travel and tourism related events',
    descriptionAr: 'ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø§Ù„Ø³ÙØ± ÙˆØ§Ù„Ø³ÙŠØ§Ø­Ø©',
    icon: 'fas fa-plane',
    color: '#0D9488',
  },
];

export async function seedEventCategories() {
  console.log('ğŸŒ± Seeding event categories...');
  
  for (const categoryData of eventCategoriesData) {
    await prisma.eventCategory.upsert({
      where: { name: categoryData.name },
      update: categoryData,
      create: categoryData,
    });
  }
  
  console.log('âœ… Event categories seeded successfully');
}
```

#### 2. ØªØ­Ø¯ÙŠØ« Ù…Ù„Ù Ø§Ù„Ø¨Ø°ÙˆØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ

**apps/api/prisma/seed.ts:**
```typescript
import { PrismaClient } from '@prisma/client';
import { seedEventCategories } from './seeds/event-categories';

const prisma = new PrismaClient();

async function main() {
  console.log('ğŸš€ Starting database seeding...');
  
  try {
    await seedEventCategories();
    
    console.log('ğŸ‰ Database seeding completed successfully!');
  } catch (error) {
    console.error('âŒ Database seeding failed:', error);
    throw error;
  }
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

#### 3. Ø¥Ø¶Ø§ÙØ© Ø£Ù…Ø± Ø§Ù„Ø¨Ø°ÙˆØ± ÙÙŠ package.json

**apps/api/package.json:**
```json
{
  "scripts": {
    "db:seed": "tsx prisma/seed.ts",
    "db:reset": "prisma migrate reset --force && npm run db:seed",
    "db:fresh": "prisma db push && npm run db:seed"
  }
}
```

#### 4. Ù…ÙƒÙˆÙ† Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª

**apps/web/src/components/events/EventsStats.tsx:**
```tsx
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Calendar, Users, MapPin, Video } from 'lucide-react';

interface EventsStatsProps {
  stats: {
    totalEvents: number;
    totalRegistrations: number;
    onlineEvents: number;
    upcomingEvents: number;
  };
}

export default function EventsStats({ stats }: EventsStatsProps) {
  const statsData = [
    {
      title: 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª',
      value: stats.totalEvents,
      icon: Calendar,
      color: 'text-blue-600',
      bgColor: 'bg-blue-100',
    },
    {
      title: 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†',
      value: stats.totalRegistrations,
      icon: Users,
      color: 'text-green-600',
      bgColor: 'bg-green-100',
    },
    {
      title: 'ÙØ¹Ø§Ù„ÙŠØ§Øª Ù‚Ø§Ø¯Ù…Ø©',
      value: stats.upcomingEvents,
      icon: MapPin,
      color: 'text-purple-600',
      bgColor: 'bg-purple-100',
    },
    {
      title: 'ÙØ¹Ø§Ù„ÙŠØ§Øª Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†',
      value: stats.onlineEvents,
      icon: Video,
      color: 'text-orange-600',
      bgColor: 'bg-orange-100',
    },
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
      {statsData.map((stat, index) => (
        <Card key={index}>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              {stat.title}
            </CardTitle>
            <div className={`p-2 rounded-md ${stat.bgColor}`}>
              <stat.icon className={`h-4 w-4 ${stat.color}`} />
            </div>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stat.value.toLocaleString()}</div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}
```

---

## Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© | Expected Deliverables

### âœ… Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ­Ù‚Ù‚

#### Backend APIs
- [ ] Event CRUD APIs Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª
- [ ] Event Categories CRUD APIs
- [ ] Registration system Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
- [ ] Attendee management ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
- [ ] Ù†Ø¸Ø§Ù… Ø§Ù„ÙÙ„ØªØ±Ø© ÙˆØ§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
- [ ] APIs Ù„Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆØ§Ù„ØªÙ‚Ø§Ø±ÙŠØ±

#### Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
- [ ] Event model Ù…Ø­Ø¯Ø« Ù…Ø¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
- [ ] EventCategory model
- [ ] EventType enum Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹
- [ ] EventRegistration Ù…Ø¹ Ø­Ø§Ù„Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
- [ ] Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ù„Ù„ÙØ¦Ø§Øª
- [ ] ÙÙ‡Ø±Ø³Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø£Ø¯Ø§Ø¡

#### ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
- [ ] ØµÙØ­Ø© Ø¹Ø±Ø¶ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ù…Ø¹ Ø§Ù„ÙÙ„Ø§ØªØ±
- [ ] Ù…ÙƒÙˆÙ† EventCard Ù…Ø­Ø³Ù†
- [ ] EventTypeFilter Ù„Ù„ØªØµÙ†ÙŠÙ
- [ ] ØµÙØ­Ø© ØªÙØ§ØµÙŠÙ„ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ© Ù…Ø­Ø¯Ø«Ø©
- [ ] Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
- [ ] Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
- [ ] ÙˆØ§Ø¬Ù‡Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙØ¦Ø§Øª

#### Ù…ÙŠØ²Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
- [ ] Ø¯Ø¹Ù… Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†
- [ ] Ù†Ø¸Ø§Ù… Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª (Tags)
- [ ] Ø¯Ø¹Ù… Ø§Ù„Ù„ØºØ§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
- [ ] Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø©
- [ ] Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø­Ø³Ù†
- [ ] Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
- [ ] ØªÙ‚ÙˆÙŠÙ… Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ

#### Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¬ÙˆØ¯Ø©
- [ ] Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙˆØ­Ø¯Ø© Ù„Ù„Ù€ APIs
- [ ] Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„ØªÙƒØ§Ù…Ù„
- [ ] Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
- [ ] Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
- [ ] Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ÙƒÙˆØ¯ ÙˆØ§Ù„Ø£Ù…Ø§Ù†

#### Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
- [ ] Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª ÙˆØ§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª
- [ ] Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ù…Ù…ØªÙ„Ø¦Ø©
- [ ] Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ°Ø§ÙƒØ± Ø§Ù„Ø±Ù‚Ù…ÙŠØ© Ù…Ø¹ QR Code
- [ ] ØªÙƒØ§Ù…Ù„ Ø§Ù„ØªÙ‚ÙˆÙŠÙ… (Google/Outlook/Apple)
- [ ] Ø¯Ø¹Ù… Ù…ØªÙ‚Ø¯Ù… Ù„Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
- [ ] Ù…Ø³Ø­ Ø§Ù„ØªØ°Ø§ÙƒØ± ÙˆØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
- [ ] Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø© Ù„Ù„Ù…Ù†Ø¸Ù…ÙŠÙ†
- [ ] ØªØµØ¯ÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø¶ÙˆØ±
- [ ] Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
- [ ] ØªØªØ¨Ø¹ Ù…Ø¹Ø¯Ù„Ø§Øª Ø§Ù„Ø­Ø¶ÙˆØ±

---

## Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ© | Next Steps

ğŸ“„ **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©:** `PHASE_05_PAYMENTS_SUBSCRIPTIONS.md`

---

---

## ğŸš€ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø§Ù„Ù…Ø¶Ø§ÙØ© | Advanced Features Added

### 1. **Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª ÙˆØ§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª**
- ØªÙ‚ÙŠÙŠÙ… Ø¨Ø§Ù„Ù†Ø¬ÙˆÙ… (1-5)
- ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ù…ÙØµÙ„Ø©
- Ø®ÙŠØ§Ø± Ø§Ù„Ù†Ø´Ø± Ø§Ù„Ù…Ø¬Ù‡ÙˆÙ„
- Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
- Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª

### 2. **Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø°ÙƒÙŠØ©**
- Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù†Ø¯ Ø§Ù…ØªÙ„Ø§Ø¡ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ©
- ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
- ØªÙ‚Ø¯ÙŠØ± Ø²Ù…Ù† Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
- Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ÙÙˆØ±ÙŠØ© Ø¹Ù†Ø¯ ØªÙˆÙØ± Ù…Ù‚Ø¹Ø¯
- ØªØ³Ø¬ÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±

### 3. **Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ°Ø§ÙƒØ± Ø§Ù„Ø±Ù‚Ù…ÙŠØ©**
- ØªÙˆÙ„ÙŠØ¯ QR Code ÙØ±ÙŠØ¯ Ù„ÙƒÙ„ ØªØ°ÙƒØ±Ø©
- ÙƒÙˆØ¯ ØªØ°ÙƒØ±Ø© Ø¢Ù…Ù† ÙˆÙ…Ø´ÙØ±
- ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ°ÙƒØ±Ø© ÙƒÙ€ PDF
- Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ°ÙƒØ±Ø© Ø¹Ø¨Ø± Ø§Ù„Ø¨Ø±ÙŠØ¯
- ØªØªØ¨Ø¹ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…

### 4. **ØªÙƒØ§Ù…Ù„ Ø§Ù„ØªÙ‚ÙˆÙŠÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…**
- Ø¯Ø¹Ù… Google Calendar
- Ø¯Ø¹Ù… Microsoft Outlook
- Ø¯Ø¹Ù… Apple Calendar
- ØªØµØ¯ÙŠØ± Ù…Ù„ÙØ§Øª ICS
- Ù…Ø²Ø§Ù…Ù†Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù„Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª

### 5. **Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø©**
- Ø±ÙˆØ§Ø¨Ø· Ø§Ø¬ØªÙ…Ø§Ø¹Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©
- ÙƒÙ„Ù…Ø§Øª Ù…Ø±ÙˆØ± Ù„Ù„Ø§Ø¬ØªÙ…Ø§Ø¹Ø§Øª
- Ø±ÙˆØ§Ø¨Ø· Ø¨Ø« Ù…Ø¨Ø§Ø´Ø±
- Ù…ÙˆØ§Ø¯ ØªØ¯Ø±ÙŠØ¨ÙŠØ© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ­Ù…ÙŠÙ„
- Ø¯Ø¹Ù… Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠØ©

### 6. **Ù…Ø³Ø­ Ø§Ù„ØªØ°Ø§ÙƒØ± ÙˆØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„**
- Ù…Ø³Ø­ QR Code Ø¨Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
- Ø¥Ø¯Ø®Ø§Ù„ ÙŠØ¯ÙˆÙŠ Ù„Ù„Ø£ÙƒÙˆØ§Ø¯
- ØªØ­Ù‚Ù‚ ÙÙˆØ±ÙŠ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªØ°ÙƒØ±Ø©
- ØªØ³Ø¬ÙŠÙ„ ÙˆÙ‚Øª Ø§Ù„Ø¯Ø®ÙˆÙ„
- Ù…Ù†Ø¹ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ØªÙƒØ±Ø±

### 7. **Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆØªÙ‚Ø§Ø±ÙŠØ± Ù…ØªÙ‚Ø¯Ù…Ø©**
- Ù…Ø¹Ø¯Ù„Ø§Øª Ø§Ù„Ø­Ø¶ÙˆØ± Ø§Ù„ÙØ¹Ù„ÙŠ
- Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
- ØªØªØ¨Ø¹ Ø¹Ù…Ù„ÙŠØ§Øª ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
- ØªØµØ¯ÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø¶ÙˆØ±
- ØªØ­Ù„ÙŠÙ„ Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª

### 8. **ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**
- Ù…ÙƒÙˆÙ† Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ
- Ø¹Ø±Ø¶ Ø­Ø§Ù„Ø© Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
- Ø§Ù„ØªØ°ÙƒØ±Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
- Ù…Ø³Ø­ QR Code Ù„Ù„Ù…Ù†Ø¸Ù…ÙŠÙ†
- Ù„ÙˆØ­Ø© Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø´Ø§Ù…Ù„Ø©

---

## ğŸ“Š **Ù…Ù‚Ø§Ø±Ù†Ø© Ù‚Ø¨Ù„ ÙˆØ¨Ø¹Ø¯ Ø§Ù„ØªØ·ÙˆÙŠØ±**

### **Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª:**
- ØªØ³Ø¬ÙŠÙ„ Ø¨Ø³ÙŠØ· Ù„Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
- Ø¹Ø±Ø¶ Ø£Ø³Ø§Ø³ÙŠ Ù„Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª
- Ù†Ø¸Ø§Ù… ØªØ³Ø¬ÙŠÙ„ ØªÙ‚Ù„ÙŠØ¯ÙŠ
- Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ‚ÙŠÙŠÙ…Ø§Øª
- Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù†ØªØ¸Ø§Ø±

### **Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª:**
âœ… **Ù†Ø¸Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„ Ù„Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª**  
âœ… **ØªØ¬Ø±Ø¨Ø© Ù…Ø³ØªØ®Ø¯Ù… Ù…ØªÙ‚Ø¯Ù…Ø©**  
âœ… **Ø¥Ø¯Ø§Ø±Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ù„Ù…Ù†Ø¸Ù…ÙŠÙ†**  
âœ… **ØªÙ‚ÙŠÙŠÙ…Ø§Øª ÙˆÙ…Ø±Ø§Ø¬Ø¹Ø§Øª**  
âœ… **Ù†Ø¸Ø§Ù… Ø§Ù†ØªØ¸Ø§Ø± Ø°ÙƒÙŠ**  
âœ… **ØªØ°Ø§ÙƒØ± Ø±Ù‚Ù…ÙŠØ© Ø¢Ù…Ù†Ø©**  
âœ… **ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Ø§Ù„ØªÙ‚Ø§ÙˆÙŠÙ…**  
âœ… **Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø´Ø§Ù…Ù„Ø©**  

---

## ğŸ¯ **Ø§Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹**

### **Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:**
- ØªØ¬Ø±Ø¨Ø© ØªØ³Ø¬ÙŠÙ„ Ø³Ù„Ø³Ø© ÙˆÙ…ØªØ·ÙˆØ±Ø©
- Ø¥Ù…ÙƒØ§Ù†ÙŠØ© ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª ÙˆÙ…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø¢Ø±Ø§Ø¡
- Ù‚Ø§Ø¦Ù…Ø© Ø§Ù†ØªØ¸Ø§Ø± Ø°ÙƒÙŠØ© Ù„Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©
- ØªØ°Ø§ÙƒØ± Ø±Ù‚Ù…ÙŠØ© Ø³Ù‡Ù„Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
- ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Ø§Ù„ØªÙ‚Ø§ÙˆÙŠÙ… Ø§Ù„Ø´Ø®ØµÙŠØ©

### **Ù„Ù„Ù…Ù†Ø¸Ù…ÙŠÙ†:**
- Ø£Ø¯ÙˆØ§Øª Ø¥Ø¯Ø§Ø±Ø© Ù…ØªÙ‚Ø¯Ù…Ø© ÙˆÙ…ØªÙƒØ§Ù…Ù„Ø©
- Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø© Ø¹Ù† Ø§Ù„Ø£Ø¯Ø§Ø¡
- Ù†Ø¸Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø¢Ù…Ù† ÙˆÙ…ØªØ·ÙˆØ±
- Ø¥Ø¯Ø§Ø±Ø© Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©
- ØªÙ‚Ø§Ø±ÙŠØ± Ø´Ø§Ù…Ù„Ø© Ø¹Ù† Ø§Ù„Ø­Ø¶ÙˆØ±

### **Ù„Ù„Ù…Ù†ØµØ©:**
- Ø²ÙŠØ§Ø¯Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© ÙˆØ§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
- ØªØ­Ø³ÙŠÙ† Ø¬ÙˆØ¯Ø© Ø§Ù„ÙØ¹Ø§Ù„ÙŠØ§Øª Ø§Ù„Ù…Ù†Ø´ÙˆØ±Ø©
- Ø¨ÙŠØ§Ù†Ø§Øª Ù‚ÙŠÙ…Ø© Ø¹Ù† ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
- Ù…ÙŠØ²Ø© ØªÙ†Ø§ÙØ³ÙŠØ© Ù‚ÙˆÙŠØ© ÙÙŠ Ø§Ù„Ø³ÙˆÙ‚
- Ø¥Ù…ÙƒØ§Ù†ÙŠØ§Øª ØªØ³ÙˆÙŠÙ‚ÙŠØ© Ù…ØªÙ‚Ø¯Ù…Ø©

---

**ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡:** 24 Ø£ÙƒØªÙˆØ¨Ø± 2025  
**Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«:** 1 Ù†ÙˆÙÙ…Ø¨Ø± 2025  
**Ø§Ù„Ø­Ø§Ù„Ø©:** ğŸŸ¢ Ù…Ø­Ø¯Ø« Ø¨Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© - Ø¬Ø§Ù‡Ø² Ù„Ù„ØªÙ†ÙÙŠØ°
